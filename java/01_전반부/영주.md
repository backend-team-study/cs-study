# 01. Java 전반부

> 김영주

<br>

### 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.

불변 객체란 '재할당은 가능하지만, 한번 할당했을 때 내부 값을 변경할 수 없는 객체'를 말한다. 문자열, 정수, 실수, 논리형 타입들이 그 예시이다.

참조 타입의 경우도 불변 객체로 만들 수 있다. 클래스의 멤버 변수들에 final 키워드를 붙여서 재할당을 금지하는 방식을 사용할 수 있다.

이렇게 하면 setter 자체를 선언할 수 없으므로, 외부에서 클래스 내의 변수 값을 변경할 수 없다. 

하지만 멤버 변수가 기본 타입이 아니라 참조 타입이라면, 직접 참조 혹은 getter를 통해서 값을 변경할 수 있다. 따라서 직접 참조할 수 없도록 멤버 변수에

private 접근 제한자를 붙이고, 조회 시 방어적 복사를 이용해서 복제본을 반환할 수 있도록 해야한다.



### 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?

1. final 키워드를 이용해 변수의 재할당을 막거나, 불변 객체를 통해서 내부 값 수정을 막으면, 다른 개발자와의 협업 혹은 유지보수 상황에서 발생할 수 있는 실수나 사고를 방지할 수 있다.
2. 불변 객체를 사용하면 수정 작업이 불가능 하므로 병렬 프로그래밍 멀티 스레드 환경에서 유리하다. 특정 공유 자원에 대한 동기화를 고려하지 않아도 되고, 항상 같은 값을 조회할 수 있도록만 하면 되기 때문이다.
3. 불변 객체 A가 있다고 할 때, A가 가지는 참조 객체인 B는 어떠한 재할당이나 변경도 불가능할 것이다. 따라서 가비지 컬렉터 입장에서 A 객체가 살아있다는 의미는 내부에 불변으로 선언된 B도 변경되지 않고 그대로 유지되고 있다는 의미이므로, B에 대해서 가비지 컬렉팅 작업을 하지 않아도 된다. 이로 인해 GC의 성능을 높일 수 있다.



### Call by Reference와 Call by Value 의 차이

call by value와 call by reference는 프로그래밍 언어에서 메서드의 매개변수를 어떤 방식으로 넘길 것인지 결정하는 평가 전략에 해당하는 개념이다.

call by value는 인자를 넘길 때 값 자체를 복사하여 넘기는 방식을 의미하고, call by reference는 인자를 넘길 때 참조를 넘기는 방식을 의미한다.

따라서 call by value로 넘긴 인자는 메서드 내에서 변경을 하더라도 원래 변수에 영향을 주지 못한다. 반면에 call by reference로 넘긴 인자는 메서드 내에서 변경을 했을 때, 원래 변수와 참조로 이어져있기 때문에 영향을 준다.

java에서는 기본 자료형에 대해서는 call by value, 참조 자료형에 대해서는 call by reference로 매개변수가 전달된다고 알려져 있으나, 이는 잘못된 개념이다.

만약 java가 참조형에 대해 call by reference를 사용했다면, 객체에 대한 재할당의 경우에도 원본이 함께 재할당 되어야 한다. 하지만 그렇지 않은데 이는 원본의 주소값이 복사되어 매개변수로 넘겨지기 때문이다. 즉, 엄밀히 말하면 참조형도 주소값을 call by value로 넘긴다고 할 수 있다.



### 제네릭(Generic)

다양한 타입의 객체를 다루는 클래스나 메서드에 컴파일 시의 타입 체크를 해주는 기능을 의미한다. 타입 옆에 꺽쇠를 통해 정의할 수 있다.

제네릭을 통해 사용되는 객체의 타입을 컴파일 단에서 체크하기 때문에 타입의 안정성을 높일 수 있다. 

또한 일일히 타입을 체크하거나 임의의 형변환을 할 필요가 없으므로 코드의 가독성도 향상시킨다.

제네릭은 변성이라는 개념이 존재하는데, 변성이란 타입의 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타내는 개념이다.

즉, 타입 A가 타입 B의 하위 타입일 때, Container<A>와 Container<B> 사이에 서로 상속 관계가 있는가? 에 따라 무공변, 공변, 반공변으로 나눌 수 있다.

- 무공변은 타입 A와 B가 상속 관계라 하더라도, 이들을 제네릭 타입으로 가지는 컨테이너 타입들에는 상속 관계가 성립하지 않음을 의미한다. java에서 기본적으로 채택하는 개념이다.
- 공변은 타입 A가 B의 하위 타입이라면, Container<A>도 Container<B>의 하위 타입이라는 것을 의미한다. java에서는 extends를 통해 선언한다.
- 반공변은 타입 A가 B의 하위 타입이라면, Container<A>는 Container<B>의 상위 타입이라는 것을 의미한다. java에서는 super를 통해 선언한다.



### Wrapper class (Boxing/Unboxing)

기본 자료형을 객체로 다루기 위해서 사용하는 클래스를 Wrapper class라고 한다. java.lang 패키지에 포함되어 있으므로 기본적으로 제공된다.

Byte, Short, Integer, Long, Float, Double, Character, Boolean 의 8개의 wrapper class가 존재한다.

Boxing이란 기본 자료형을 래퍼 클래스의 인스턴스로 변환하는 것을 말하고, Unboxing은 래퍼 클래스의 인스턴스에 저장된 값을 기본 자료형으로 변환하는 것을 말한다.

jdk 1.5부터는 이런 박싱과 언박싱을 자동으로 처리해주기 시작했다. (이를 auto boxing, auto unboxing이라고 한다.) 대입 혹은 연산 시 자동으로 변환된다.

wrapper class의 동등 비교를 할 때는 equals() 메서드를 사용해야 한다. ==는 객체의 주소값을 비교하는 동일 연산자이기 때문이다. 단, 기본 자료형과 wrapper class의 비교는 오토 박싱으로 인해 ==도 가능하다.

wrapper class를 사용하는 이유는 다음과 같다. 제네릭 타입에는 참조 자료형 가능하므로 기본 자료형을 넣을 수 없다. 따라서 wrapper class를 통해 제네릭 타입으로 지정할 수 있다. 또한 null을 할당하거나, 기본 자료형과 관련된 다양한 메서드를 사용하기 위해서도 wrapper class를 사용한다.



### String & StringBuffer & StringBuilder

String(문자열)은 불변 객체이므로 내용을 변경할 수 없고, 변경된 내용의 새로운 문자열은 JVM Heap 영역의 String Constant Pool에 생성된다.

따라서 문자열에 대한 수정을 여러번 하게 되면, 그만큼 Heap 영역의 메모리를 차지하게 된다. 이러한 비효율을 줄이고자 StringBuffer, StringBuilder가 탄생했다.

StringBuffer는 내부적으로 문자열의 편집을 위한 버퍼를 가진다. 인스턴스를 생성하면서 그 크기를 지정할 수 있다. 문자열을 추가하더라도 새로 객체가 생성되지 않고 기존 객체의 내용만 변경된다. 문자열로 바꾸기 위해서는 toString() 메서드를 이용한다.

StringBuilder는 StringBuffer에서 쓰레드의 동기화만 제거한 것이다. StringBuffer는 멀티 스레드 환경에서 안전하도록 동기화 되어 있는데, 이는 성능을 떨어뜨리는 원인이다. 따라서 단일 스레드 환경에서는 StringBuilder를 사용하면 성능이 좋다.

jdk 1.5부터는 String의 연산 과정에서 자동적으로 StringBuilder를 사용하도록 내부 구조가 변경되었다.



### equals()와 hashcode()에 대해 설명해 주세요.

equals() 메서드는 매개변수로 객체의 참조 변수를 받아서 비교하여 그 결과를 논리형으로 반환하는 역할을 한다. 기본적으로 Object 클래스 내에서는 equals() 메서드가 ==로 정의되어 있다. 즉 원래의 기능은 두 객체 자체가 동일한 객체인지를 비교하여 true, false로 돌려주는 것이다.

동일 비교가 아니라, 두 객체의 값이 같은지를 비교하는 동등 비교를 하기 위해서는 equals()를 오버라이딩 해야 한다.

hashCode() 메서드는 객체에 대한 해시 함수 역할을 한다. 객체의 물리적 주소값을 이용해 해시코드를 생성한다. 그리고 이는 객체를 구별하는 고유한 값이 된다.

equals()와 hashCode()는 반드시 같이 오버라이딩 해야한다. 그렇지 않으면, HashSet, HashMap과 같은 해시 자료구조를 사용할 때 문제가 발생한다.

HashSet, HashMap은 객체의 해시코드를 기준으로 객체를 구별하여 중복을 방지한다. 만약 특정 클래스에 대해 equals()만 오버라이딩을 해서 두 인스턴스가 equals() 상으로는 true가 나온다 하더라도, hashCode() 상으로는 전혀 다른 해시 코드를 반환하므로, HashSet이나 HashMap에서는 다른 객체라고 취급 받아 중복제거가 되지 않을 것이다.

참고로 HashSet, HashMap은 먼저 객체의 해시 코드를 보고 같으면 equals()의 결과를 본다. 두 결과가 모두 같으면 그때서야 동등한 객체라고 판단한다.

둘 중 하나라도 결과가 다르면 동등하지 않은 객체라고 판단하여 자료구조 내에 저장한다.



### new String()과 리터럴("")의 차이에 대해 설명해주세요.

문자열 리터럴의 경우 JVM Heap 영역에 있는 String Constant Pool에서 관리된다. 

따라서 문자열을 리터럴로 할당할 때, String 클래스 내부적으로 intern() 메서드를 호출하여 일단 String Constant Pool에 해당 리터럴이 있는지 확인하고 있으면 그대로 가져오고, 없으면 새로 생성한다.

반면 new String()으로 문자열을 할당하는 경우, String Constant Pool이 아닌 Heap 영역에 문자열 객체를 새로 생성하기 때문에, 값이 같더라도 여러 문자열 객체가 존재할 수 있다.



### JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.

JVM(Java Virtual Machine)은 자바 가상 머신으로, 자바 프로그램을 컴파일 해서 나온 결과인 바이트코드를 실행시켜주는 역할을 한다.

JVM을 사용하는 이유는 언어가 운영체제에 종속적이지 않게 하기 위함이다. C언어의 경우는 컴파일러가 소스코드를 기계어로 변환하여 실행파일을 만든다.

이때 실행파일은 특정 OS 내에서의 실행파일이므로 OS에 종속적이다. 하지만 자바의 컴파일 결과는 기계어가 아닌 바이트코드이므로 OS에 종속적이지 않다.

JVM은 해당 바이트코드를 읽어 각 OS에 맞는 기계어로 변환한다.



JVM은 클래스로더와, 런타임 데이터 영역, 실행 엔진으로 구분된다.

- **클래스로더**
  - 사람이 작성한 소스코드를 javac (자바 컴파일러)가 바이트코드 파일(.class 파일)로 변환한다. (컴파일 단계)
  - 이후 런타임 상황에서 특정 클래스를 참조할 때 클래스로더는 해당 바이트코드를 JVM에 로딩하여 클래스 정보를 읽어온다.
  - 로드 -> 검증 -> 준비 -> 분석 -> 초기화 단계를 거친다.

- **런타임 데이터 영역**
  - 클래스로딩이 끝나면 런타임 데이터 영역이라는 곳에 메모리를 할당받는다.
  - `PC 레지스터` : 현재 수행 중인 JVM 명령의 주소를 가진다.
  - `스택 영역` : 스택 프레임 구조체를 저장하는 스택 자료구조이다. 메서드가 수행될 때마다 하나의 스택 프레임이 쌓인다. 스택 프레임에는 지역 변수 배열과 피연산자 스택 그리고 상수 풀에 대한 참조가 담긴다.
  - `네이티브 메서드 스택` : 자바 외의 언어로 작성된 네이티브 코드들을 위한 스택이다.
  - `메서드 영역` : JVM이 읽어들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, static 변수, 메서드의 바이트 코드등을 보관한다. 런타임 상수 풀이란 각 클래스와 인터페이스의 상수 뿐만 아니라 메서드와 필드에 대한 모든 레퍼런스를 담은 테이블이다.
  - 힙 영역 : 인스턴스 또는 객체와 배열을 저장하는 공간으로, 가비지 컬렉션의 대상이 되는 영역이다.
- **실행 엔진**
  - 클래스로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다.
  - 바이트코드를 명령어 단위로 읽어서 실행한다.
  - 실행 엔진은 바이트코드를 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하는데 이는 두 가지 방식이 있다.
    - 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다.
    - JIT 컴파일러 : 인터프리터의 단점을 보완하고자 나왔다. 인터프리터 방식으로 실행하다가 반복되는 부분에 대해 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 메서드를 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행한다.



JVM의 장점은 높은 이식성, GC에 의한 자동 메모리 관리, 보안 향상, 동적 로딩을 통한 유연성과 확장성이 있다.

JVM의 단점은 기계어로 바로 해석하는 것에 비해 속도가 느리고, GC등의 추가 작업에 의한 메모리 사용량 증가, 최초 로딩 시간의 지연 등이 있다.



JVM 내부에서 실행되는 프로그램은 스레드 단위로 실행된다. 즉 하나의 프로세스 내에서 여러 스레드가 사용되는 구조이므로 부모-자식 프로세스 구조를 가지지는 않는다.



### Java의 GC에 대해 설명해 주세요.

동적으로 할당했던 메모리 영역 중 더이상 사용하지 않는 영역을 정리하는 메모리 관리 기법이다. JVM의 힙 영역에서 활동하며 사용하지 않는 인스턴스를 제거한다.

GC는 도달성을 평가하여 제거할 대상을 지정한다. Root Space로 부터 객체에 참조가 없는 경우는 도달 불가능으로 GC의 제거 대상이 된다.



**작동 방식**

- Stop the world
  - GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 의미한다.
  - GC를 실행하는 스레드만 동작하고, 나머지 모든 스레드는 멈춘다.
  - GC를 튜닝한다는 것은 Stop the world 시간을 줄이는 것을 말한다.
- Mark and sweep
  - mark : Root space로부터 그래프 순회를 통해 어떤 객체를 참조하는지 마킹한다. 즉 도달성 여부를 결정한다.
  - sweep : 도달 불가능한 객체들을 제거한다.
  - compact : sweep 이후 메모리 곳곳에 퍼져있는 객체들을 힙 영역의 시작 주소로 모아 메모리 압축을 진행한다.



참고로 Root space란 `스택 영역 + 네이티브 스택 + 메서드 영역`을 의미한다.



**GC는 두 가지 전제 조건 하에 이루어진다.**

1. 대부분의 객체는 빠르게 도달 불가능 상태가 된다.
2. 오래된 객체에서 젊은 객체로의 참조는 매우 적다.

이러한 조건의 장점을 살리고자, 힙 영역을 크게 Young Generation과 Old Generation으로 나누었다.

- **Young Generation (Minor GC)**
  - 새롭게 생성한 객체의 대부분이 위치하는 영역이다.
  - 대부분 객체는 Young 영역에 생성되었다 사라진다.
  - Young 영역은 아래와 같이 세 영역으로 나뉜다.
    - Eden : 새로 생성한 객체가 위치하는 곳이다. GC 한 번 활동 후 살아남은 객체는 Survivor 영역으로 이동한다.
    - Survivor 0, 1 : Eden 영역에서 한번이라도 살아남은 객체가 이동하는 곳이다. 여기서 한번씩 살아남을 때마다 각 객체의 Age가 1씩 증가한다. 일단 하나의 Survivor 영역에 가득 채우고, 그 중에서 살아남은 객체들을 다른 Survivor 영역으로 옮기고 기존 Survivor 영역은 비운다.
- **Old Generation (Major GC)**
  - Young 영역의 Survivor에서 여러 번 옮겨져서 살아남은 객체들이 위치하는 영역이다.
  - Young 영역보다 크게 할당하며, Young 영역보다 GC가 적게 발생한다. Young 영역의 Minor GC보다 약 10배 이상의 시간이 소요된다.
  - Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우가 있는데, 이때는 Old 영역의 512 바이트 짜리 카드 테이블을 이용한다. 카드 테이블에는 Old 영역의 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시된다. 따라서 Young 영역의 Minor GC 과정에서 Old 영역의 참조를 모두 보는 것이 아니라, 카드 테이블만 봄으로써 효율성을 향상시킨다.



### 접근 제어자에 대해 설명해주세요.

`접근 제어자(Access Modifier)`란, 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 키워드이다.

클래스, 클래스 변수, 인스턴스 변수, 메서드, 생성자에 붙일 수 있다.



**사용 이유**

- 클래스 내부에 선언된 데이터를 보호하기 위함이다.
- 클래스 내에서만 사용되는 변수나 메서드를 클래스 내부에 감추어, 외부에서 사용되지 않는 불필요한 정보들을 드러내지 않아 복잡성을 줄이기 위함이다.
- 결국은 접근 제어자는 객체지향의 `캡슐화` 개념을 위해 사용된다.



**종류**

- private : 같은 클래스 내에서만 해당 대상을 접근할 수 있다.
- default : 같은 패키지 내에서만 해당 대상을 접근할 수 있다.
- protected : 같은 패키지 내 그리고 다른 패키지의 자손 클래스에서 접근할 수 있다.
- public : 접근 제한이 전혀 없다.



**사용 가능 대상**

- `클래스` : public, default
- `클래스 변수, 인스턴스 변수, 메서드` : public, protected, default, private
- `지역 변수` : 없음



### 오버로딩과 오버라이딩의 차이

**오버로딩(Overloading)**은 한 클래스 내에 같은 이름의 메서드를 여러 개 정의할 수 있는 것을 말한다.

메서드의 이름이 같고, 매개변수의 개수나 타입이 달라야 한다는 조건이 있다. 반환 값이나 접근 제어자만 다른 것은 오버로딩 할 수 없다.



**오버라이딩(Overriding)**은 부모 클래스로부터 상속받은 메서드를 자식 클래스에서 재정의 하는 것을 말한다.

자식 클래스에서는 부모 클래스의 메서드의 이름, 매개변수, 리턴 값이 모두 같아야 한다. (메서드 시그니처가 같고, 반환 타입은 같거나 하위 타입이어야 한다.)

단, 자식 클래스에서 재정의 할 때 접근 제어자는 부모 클래스의 접근 제어자보다 같거나 넓은 범위여야 한다.

그리고 예외의 경우도 부모보다 더 많이 선언할 수 없으며, static 메서드는 오버라이딩 할 수 없다. 단순히 새로 정의하는 것이다.