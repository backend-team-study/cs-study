# 02. Join, 이상현상과 정규화
> 김영주

<br>

## 2.1. Join

![image](https://github.com/dev-team-study/cs-study/assets/49775540/1157e156-92c3-47be-acc7-df22ba4e27a9)



`Join`이란 DB 내의 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현하는 것을 말한다.

- **Inner Join**

  ```sql
  SELECT <열 목록>
  FROM <기준 테이블>
      INNER JOIN<참조할 테이블>
      ON <조인 조건>
  WHERE 검색조건;
  ```

  - 조인하는 테이블의 ON 절의 조건이 일치하는 결과만 출력한다.
  - 교집합에 해당한다.

- **Outer Join**

  ```sql
  SELECT <열 목록>
  FROM <첫 번째 테이블(LEFT)>
      <LEFT | RIGHT | FULL> [OUTER] JOIN <두 번째 테이블(RIGHT)>
      ON <조인 조건>
  WHERE 검색조건;
  ```

  - `Left Join` : 왼쪽 테이블을 기준으로 모든 레코드가 표시되고, 오른쪽 테이블에 없는 내용은 NULL로 표시된다.
  - `Right Join` : 오른쪽 테이블을 기준으로 모든 레코드가 표시되고, 왼쪽 테이블에 없는 내용은 NULL로 표시된다.
  - `Full Join` : 왼쪽, 오른쪽 테이블을 기준으로 모든 레코드가 표시된다. 서로 없는 내용은 NULL로 표시된다.
    - MySQL은 Full Join에 대한 문법이 따로 없기 때문에, UNION을 사용해서 Full Join을 구현해야한다.

<br>

## 2.2. 이상현상

> `이상(Anomaly)`이란, 데이터베이스를 잘못 설계하여 불필요한 데이터 중복이 발생해 릴레이션에 대한 CRUD를 실행할 때 부작용이 나타나는 것을 말한다.

이상현상은 보통 동일한 데이터가 여러 번 중복되어 저장될 때 발생한다.

즉, 쉽게 생각해서 서로 분리되어야 하는 릴레이션이 합쳐져 있을 때 발생하는데, 이는 같은 부류의 데이터에 대해 연산을 할 때 관련없는 부류의 데이터에도 영향이 가기 때문이다.



1. **삽입 이상(Insertion Anomaly)**
   - 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
   - 고객 데이터를 삽입하고 싶은데, 이벤트 참여 내역도 같은 릴레이션에 있는 경우, 이벤트에 참여하지 않았더라도 고객 데이터를 삽입함으로써 pk에 해당하는 이벤트 참여 내역이 NULL이 되어버려 개체 무결성 제약 조건을 위반한다.
2. **갱신 이상(Update Anomaly)**
   - 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
   - 고객 데이터는 똑같고, 이벤트 참여 내역만 다른 여러 튜플이 있는 경우, 한 튜플의 고객 데이터를 변경하면 다른 튜플들의 고객 데이터도 변경되어야 하지만 그렇지 못하기 때문에 데이터의 불일치가 발생한다.
3. **삭제 이상(Deletion Anomaly)**
   - 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제
   - 이벤트 참여 내역만 지우고 싶은데, 같은 릴레이션에 있기 때문에 고객 데이터도 함께 삭제된다.



이러한 이상현상을 해결하려면 어떻게 해야할까? 바로 정규화가 필요하다.

`정규화(Normalization)`란, 이상현상이 발생하지 않도록 **관련있는 속성들로만 구성하기 위해 릴레이션을 분해하는 것을 의미**한다.

<br>

## 2.3. 함수 종속

정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 한다. 이때 관련성을 `함수적 종속성(Functional Dependency, FD)`이라고 한다.



하나의 릴레이션을 구성하는 속성들의 부분 집합을 X와 Y라고 할 때,

`"Y가 X에 함수적으로 종속되어 있다."`

= X가 Y를 함수적으로 결정한다.

= 모든 튜플에서 하나의 X값에 대한 Y값이 항상 하나이다.

= X -> Y (X를 결정자, Y를 종속자)



예를 들어 아래와 같은 고객 릴레이션이 있다고 가정한다.

| 고객아이디 | 고객이름 | 등급   |
| ---------- | -------- | ------ |
| apple      | 정소화   | gold   |
| banana     | 김선우   | vip    |
| carrot     | 고명석   | gold   |
| orange     | 김용욱   | silver |

- 고객아이디가 고객이름과 등급을 결정한다.
- 고객아이디에 따라 (고객이름, 등급)의 묶음이 확실히 결정되기 때문이다.
- 고객아이디가 아닌 고객이름과 같이 중복 가능성이 있는 것으로 종속성을 따져보면, 고객이름만 가지고는 나머지 데이터를 결정지을 수 없으므로 함수적 종속성을 만족하지 못한다.
- 따라서 고객아이디는 결정자가 되고, 고객이름과 등급은 종속자가 된다.



**함수적 종속성의 특징은 다음과 같다.**

- 단순히 튜플 데이터 만으로 종속성을 판단하지는 않는다. 해당 속성의 특성을 고려해야 한다.
  - 고객아이디의 특성 상, 중복이 될 수 없기 때문에 고객아이디가 정해지면 나머지 속성들의 값들도 분명하게 결정된다.

- 기본키나 후보키만 결정자가 될 수 있는 것은 아니다. 다른 속성 값을 유일하게 결정할 수 있다면 해당 속성은 결정자가 될 수 있다.
- 결정자와 종속자가 동일하거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않는다.
  - 예) 고객아이디 -> 고객아이디
  - 예) {고객아이디, 이벤트번호} -> 이벤트번호



**함수적 종속성의 종류는 다음과 같다.**

- `완전 함수 종속(Full Functional Dependency, FFD)` : 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있으나, X 전체에 종속 된 것이지 일부분에 종속된 것이 아님을 의미한다. 일반적으로 함수 종속이라고 하면 완전 함수 종속을 의미한다.
- `부분 함수 종속(Partial Functional Dependency, PFD)` : 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다. 이때는 결정자가 여러 개의 속성들로 구성되어 있어야 한다.
- `이행적 함수 종속(Transitive Functional Dependency, TFD)` : 3개의 속성 집합 X, Y, Z에 대해 함수 종속 관계 X -> Y와 Y -> Z가 존재하면 논리적으로 X -> Z가 성립하는 것을 의미한다. (속성 집합 Z가 속성 집합 X에 이행적으로 함수 종속되었다고 표현)

<br>

## 2.4. 정규형

> `정규화(Normalization)` : 함수 종속성을 이용해 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여, 이상현상이 발생하지 않도록 하는 것

릴레이션이 정규화된 정도는 정규형(Normal Form, NF)으로 표현한다.

각 정규형마다 만족시켜야 하는 제약조건이 존재한다. 릴레이션이 특정 정규형의 제약조건을 만족하면 해당 정규형에 속한다고 표현한다.

정규형의 차수가 높아질수록 제약조건이 많고 엄격하다. 따라서 릴레이션 특성을 고려해서 적합한 정규형을 선택해야한다.

<br>

### 기본 정규형

> 일반적으로 기본 정규형은 지키도록 릴레이션을 정규화하는 것이 대부분이다.

1. **제 1 정규형 (1NF)** 
   - `릴레이션에 속한 모든 속성이 도메인의 원자 값으로만 구성되어 있으면 제 1 정규형에 속한다.`
   - 하나의 속성에 다중 값이 삽입될 수 없다.
   - 제 1 정규형을 만족해도 삽입, 갱신, 삭제 이상이 발생할 수 있다. 단순히 다중 값을 없애고 튜플을 추가한 것 뿐이라 데이터 자체의 중복을 막지는 못한다. (아직 부분 함수 종속성이 남아있기 때문) => 따라서 부분 함수 종속성을 없애기 위해 릴레이션을 분리해야 한다.
2. **제 2 정규형 (2NF)**
   - `릴레이션이 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2 정규형에 속한다.`
   - 부분 함수 종속을 모두 제거하고 모든 속성이 기본키에 완전 함수 종속이 되도록 릴레이션을 분해한다. (이제 같은 부류에 맞게 테이블 분리)
   - 분해할 때의 주의점은, 분해된 릴레이션들을 자연 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다는 점이다. (= `무손실 분해`)
   - 제 2 정규형을 만족해도 함수 종속성이 여러 개라면 이상 현상이 발생할 수 있다. (무조건 기본키에 완전 함수 종속되어야 함)
     - 함수 종속성이 여러 개라는 것은, 결정자와 종속자가 여러 개라는 것이므로 부류가 두 개이상 생길 수 있게되기 때문이다.
3. **제 3 정규형(3NF)**
   - `릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형에 속한다.`
   - 이행적 함수 종속이 나타나는 이유는 하나의 릴레이션에서 함수 종속 관계가 여러 개 나타나기 때문이다. (기본키를 제외한 추가적인 함수 종속 관계가 있다면 일단 릴레이션을 쪼개야 하지 않을까 생각하면 좋을 것 같다.)
   - X -> Y -> Z 와 같이 이행적 함수 종속성이 나타나면, X -> Y 와 Y -> Z가 될 수 있도록 릴레이션을 두 개로 쪼개는 것을 권장한다.
4. **보이스/코드 정규형(BCNF)**
   - `릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스/코드 정규형에 속한다.` (= 강한 제 3 정규형, Strong 3NF)
   - 결정자에 해당하는 속성이 후보키가 아닌 경우가 있으면, 보이스/코드 정규형을 만족하지 못하며 이상현상이 발생할 수 있다.
   - 후보키는 아니라서 중복이 발생 가능한 데이터이지만, 결정자이긴 해서 해당 값이 삽입/갱신/삭제 될 때 다른 값에도 영향을 주기 때문이다.
   - 따라서 모든 결정자가 후보키에 속할 수 있도록 릴레이션을 분해해야 한다.

<br>

### 고급 정규형

5. **제 4 정규형(4NF)**
   - `릴레이션이 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속(Multi Valued Dependency, MVD)를 제거해야 제 4 정규형에 속한다.`
   - 릴레이션에 3개 이상의 컬럼이 있고, 하나의 컬럼이 나머지 두 개의 컬럼을 결정 짓는 상황에서, 나머지 두 개의 컬럼이 서로는 독립적이나 1:N의 관계를 만족하는 경우 `다치 종속`이라고 표현한다.
   - 보통 하나의 속성 도메인이 다중 값이 되지 않도록 분리하면서 많이 발생한다.
   - 서로 독립적인 두 컬럼이 1:N 관계를 형성하면서, 결정자 속성을 포함하여 튜플을 보았을 때 중복된 데이터가 존재한다.
   - 따라서 결정자 -> 하나의 컬럼, 결정자 -> 다른 하나의 컬럼 이 될 수 있도록 릴레이션을 분해해야 한다.
6. **제 5 정규형(5NF)**
   - `릴레이션이 제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속(Join Dependency, JD)를 제거해야 제 5 정규형에 속한다.`
   - 하나의 릴레이션을 여러 개의 릴레이션으로 무손실 분해했다가 다시 결합했을 때 불필요한 데이터가 추가되는 경우를 `조인 종속`이라고 표현한다.
   - 제 4 정규형을 만족하기 위해 무손실 분해 했던 릴레이션들을 다시 조인했을 때, 결정자의 값이 여러 번 등장하는 경우 결정자에 종속된 종속자들 간의 묶음이 생기면서 무손실 분해 되기 전의 모습과 달라지는 경우가 생긴다.
   - 이런 경우에는 종속자들 간에도 결정자와 종속자로 나누어 별도의 릴레이션으로 구분하여, 무손실 분해 이후 조인 했을 때 분해 전 데이터와 동일하게 맞출 수 있다.
   - 제 5 정규형은 너무 이상적인 정규화라 현실적으로는 어려운 부분이 존재한다.