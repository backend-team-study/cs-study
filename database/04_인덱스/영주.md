# 04. 인덱스

> 김영주

<br>

## 4.1. 인덱스의 개념

- 인덱스란, 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

- 마치 책의 맨 끝에 있는 `찾아보기(색인)`과 같은 역할을 한다. 여기서 중요한 포인트는 인덱스들은 `정렬`이 되어있어야 한다는 것이다.

- DBMS에서 인덱스가 많은 테이블은 `INSERT, UPDATE, DELETE` 연산이 느려진다. 

- 따라서 DBMS에서의 인덱스는 데이터의 쓰기 성능을 희생하고 읽기 성능을 높이는 기능이라고 할 수 있다.



**역할 별 구분**

- 프라이머리 키 (Primary Key)
- 세컨더리 인덱스 (Secondary Key)



**자료구조 별 구분**

- B-Tree 
- HashTable



**중복 허용 여부 구분**

- Unique Index

- Non-unique Index

<br>

## 4.2. B-Tree (Balanced-Tree) 인덱스

데이터베이스 인덱스 자료구조 가운데 가장 일반적으로 사용되는 방식이다. 여기에 추가적으로 변형된 B+Tree를 주로 사용한다.



### 구조 및 특성

- 최 상단의 루트 노드와 최 하단의 리프 노드들로 구성되어 있다. 중간의 노드는 브랜치 노드라고 한다.
- 인덱스와 실제 데이터는 따로 관리된다. 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가진다.
- 인덱스의 키 값들은 모두 정렬 상태이나, 데이터 파일의 레코드는 정렬되어 있지는 않다. (InnoDB에서는 클러스터를 통해 디스크에 저장되므로 기본적으로 PK 순서로 정렬되어 저장되긴 한다.)
- MyISAM은 세컨더리 인덱스가 물리적인 주소를 가지는 반면, InnoDB는 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.



### 키 추가 및 삭제

1. **인덱스 키 추가**
   - B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색한다.
   - 저장될 위치가 결정되면 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장한다.
   - 리프 노드가 꽉차면 분리되어야 하는데, 이는 상위 브랜치 노드까지 처리해야 하므로 B-Tree는 쓰기 작업에 많은 비용이 든다.
   - MyISAM과 달리, InnoDB는 INSERT문이 실행되면 즉시 인덱스를 B-Tree에 저장하지 않는다. 필요하다면 키 추가 작업을 지연시킬 수 있다. 하지만 PK나 유니크 인덱스의 경우 중복 체크가 필요하므로 즉시 추가된다.
2. **인덱스 키 삭제**
   - 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료된다.
   - 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 할 수 있다.
3. **인덱스 키 변경**
   - 인덱스의 키 값에 따라 저장될 리프 노드의 위치가 결정되므로, B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.
   - 따라서 B-Tree의 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
4. **인덱스 키 검색**
   - INSERT, UPDATE, DELETE 작업을 할 때, 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.
   - 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니기 때문이다.



### 인덱스 사용에 영향을 미치는 요소

1. **인덱스 키 값의 크기**
   - 페이지 혹은 블록이란 InnoDB 스토리지 엔진이 디스크에 데이터를 저장하는 가장 기본 단위를 의미한다.
   - 이는 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 즉, 인덱스 또한 페이지 단위로 관리되며 루트/브랜치/리프 노드를 구분하는 기준이된다.
   - DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree는 인덱스의 페이지와 키 값의 크기에 따라 자식 노드 개수가 정해진다. (5.7버전 부터는 기본 페이지 크기가 16KB)
   - 인덱스 키 값이 커지면 한 페이지에 저장할 수 있는 인덱스 키의 개수가 줄어든다. 즉 쿼리를 통해 읽어오는 데이터가 많아질 수록 디스크 IO가 더 많이 발생하여 느려진다는 것을 의미한다.
   - 인덱스 키 값이 커지면 전체 인덱스의 크기가 커지기도 하므로, 메모리에 캐시할 수 있는 레코드 수도 줄어든다. 자연스럽게 메모리 효율도 떨어진다.
2. **B-Tree의 깊이**
   - 인덱스 키 값이 커지면 => 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고 => 같은 레코드 건수라 해도 B-Tree의 깊이가 깊어져서 => 디스크 IO가 더 많이 필요해진다.
   - 따라서 인덱스 키 값의 크기는 가능하면 작게 만들어야 한다. 실제로는 아무리 대용량 데이터베이스라도 깊이가 5단계 이상까지 깊어지는 경우는 흔하지 않다.
3. **선택도(기수성)**
   - 선택도(Selectivity) 또는 기수성(Cardinality)란 모든 인덱스 키 값 가운데 유일한 값의 수를 의미한다.
   - 즉 카디널리티가 낮다는 것은 유일한 값의 수가 적다는 것이므로, 중복이 많다는 의미가된다.
   - 인덱스 가운데 중복된 값이 많아지면 많아질수록 카디널리티는 낮아져 검색 대상이 많아진다. 즉 속도가 느려진다.
4. **읽어야 하는 레코드 건수**
   - 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이, 테이블에서 직접 읽는 것보다 4~5배 정도 비용이 더 많이 든다고 판단한다.
   - 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽는 방식이 오히려 효율적이게 된다.



### B-Tree 인덱스를 통한 데이터 읽기

> MySQL이 인덱스를 이용하는 대표적인 세 가지 방법

1. **인덱스 레인지 스캔**

   - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

   - 레코드를 한 건만 읽든 한 건 이상을 읽는 레인지 스캔이라고 표현한다.

   - 루트 -> 브랜치 -> 리프 까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다. (index seek)

   - 레코드 시작 지점을 찾으면 리프 노드 레코드만 순서대로 읽으면 된다. 중간에 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다. (index scan)

   - 그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환한다. 반환은 레코드 한 건 단위로 랜덤 IO가 발생하므로 비용이 많이 드는 작업이다.

   - 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되므로 랜덤 IO가 줄어들고 그만큼 성능이 좋아진다.

     > 커버링 인덱스? => 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스이다. 조회 결과 컬럼이 인덱스에 해당하면 굳이 디스크에서 읽어올 필요가 없으므로 효율적이다.

2. **인덱스 풀 스캔**

   - 레인지 스캔과 마찬가지로 인덱스를 사용하지만, 인덱스의 처음부터 끝까지 모두 읽는 방식을 말한다.
   - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 풀 스캔 방식이 사용된다.
   - 인덱스 레인지 스캔보다 빠르지는 않지만, 테이블 풀 스캔보다는 효율적이다. 왜냐면 인덱스에 포함된 컬럼만으로도 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다.

3. **루스(Loose) 인덱스 스캔**

   - 타이트(tight) 인덱스 스캔(ex. 인덱스 레인지 스캔, 인덱스 풀 스캔) vs 루스(Loose) 인덱스 스캔
   - 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
   - 일반적으로 GROUP BY 또는 MAX, MIN에 대해 최적화 하는 경우에 사용된다.

4. **인덱스 스킵 스캔**
   - 다중 인덱스에 대해, 해당 다중 인덱스를 구성하는 낱개 컬럼은 원래 인덱스 처리가 될 수 없었다. MySQL 8.0부터는 옵티마이저가 이런 다중 인덱스를 구성하는 낱개 컬럼에 대해서도 인덱스 검색이 가능하도록하는 인덱스 스킵 스캔 기능이 도입되었다.
   - **단점**
     - WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유알한 값의 개수가 적어야한다.
     - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다. (커버링 인덱스여야 한다.)

<br>

## 4.3. 클러스터링 인덱스

클러스터링이란 여러 개를 하나로 묶는다는 의미로 주요 사용된다.

MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현된다.

주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것인데, 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.



### 클러스터링 인덱스

- 테이블의 `프라이머리 키`에 대해서만 적용된다. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 말한다.
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다. (키 값이 변경되면 물리적 위치도 변한다.)
- clustering index = clustering table = clustering key = primary key
- 클러스터링 테이블의 구조 자체는 일반 B-Tree와 비슷하지만, 세컨더리 인덱스의 B-Tree와 달리 리프 노드에 레코드의 모든 컬럼이 같이 저장된다.
- 만약 프라이머리 키가 없는 테이블은 어떻게 클러스터링 될까?
  - 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택한다.
  - NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택한다.
  - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택한다.



### 세컨더리 인덱스에 미치는 영향

- MyISAM에서와 같이 클러스터링 되지 않는 테이블들은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않는다.
  - 레코드가 저장된 주소는 내부 레코드 아이디(ROWID) 역할을 한다.
  - 그리고 프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터 레코드를 찾아온다.
  - 따라서 MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없다.
- InnoDB에서는 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있으면, 클러스터링 키 값이 변경될 때마다 레코드의 주소가 변경되고, 해당 테이블의 모든 인덱스에 저장된 주소값을 변경해야 할 것이다.
- 따라서 이런 오버헤드를 줄이기 위해 InnoDB 테이블에서는 모든 세컨더리 인덱스는 레코드의 주소가 아닌, 프라이머리 키 값을 저장한다.
- **정리**
  - MyISAM은 인덱스 검색 => 레코드 주소 확인 => 레코드 주소에 따른 데이터 가져옴
  - InnoDB는 인덱스 검색 => 프라이머리 키 값 확인 => 프라이머리 키 인덱스 검색 => 데이터 가져옴
  - 따라서 InnoDB가 더 복잡한 절차를 거친다. 하지만 이런 성능상의 저하에도 불구하고 더 큰 장점을 제공한다.



### 클러스터링 인덱스의 장점과 단점

> 빠른 읽기, 느린 쓰기

장점

- 프라이머리 키로 검색할 때 처리 성능이 매우 빠르다.
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에, 인덱스만으로 처리될 수 있는 경우가 많다. (커버링 인덱스)



단점

- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에, 클러스터링 키 값이 큰 경우 전체적으로 인덱스 크기가 커진다.
- 세컨더리 인덱스를 통해 검색할 때, 프라이머리 키로 다시 한번 검색해야 하므로 성능이 느리다.
- INSERT 할 때 프라이머리 키에 의해 레코드 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느리다.



### 클러스터링 테이블 사용 시 주의사항

1. 클러스터링 인덱스 키의 크기
   - 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함하므로, 프라이머리 키가 커지면 세컨더리 인덱스도 커진다.
2. 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성
   - InnoDB에서 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다.
   - 따라서 프라이머리 키로 검색하는 경우, 클러스터링 되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음을 의미한다.
   - 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 설정하는 것이 좋다.
3. 프라이머리 키는 반드시 명시할 것
   - 프라이머리 키가 없는 것 보다는, AUTO_INCREMENT 컬럼을 이용해서라도 생성하는 것을 권장한다.
   - 만약 InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 스토리지 엔진이 내부적으로 컬럼을 추가한다.
   - 이 컬럼은 내부적으로 생성되므로 사용자가 접근할 수 없다.
4. AUTO_INCREMENT 컬럼을 인조 식별자로 사용할 경우
   - 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하여 프라이머리 키로 설정한다.
   - INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.

<br>

## 4.4. 유니크 인덱스

> 같은 값이 2개 이상 저장될 수 없는 인덱스

### 인덱스 읽기

- 유니크 인덱스가 빠를 것 같지만 사실 그렇지는 않다.
- 유니크 하지 않은 세컨더리 인덱스는 단건만 읽는 유니크 인덱스와 달리, 레코드를 하나 더 읽어야 한다. 하지만 이는 CPU에서 컬럼 값을 비교하는 작업이므로 성능상 영향이 거의 없다.
- 유니크 하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아서 느린 것이다. (디스크 IO 상 느린 것이지 인덱스 자체의 특성 상 느린 것이 아니다.)
- 즉 단순히 세컨더리 인덱스는 읽어올 데이터가 많기 때문에 느린 것이지, 단위 당 속도로 따지면 차이가 거의 없다.



### 인덱스 쓰기

- 유니크 인덱스의 키 값을 쓸 때는 중복 값이 있는지 없는지 체크하기 때문에, 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
- MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용한다. 이 과정에서 데드락이 빈번히 발생한다.
- 또한 유니크 인덱스는 중복 체크 때문에 InnoDB의 체인지 버퍼를 사용하지 못한다. 따라서 일반 세컨더리 인덱스보다 변경 작업이 느릴 수 밖에 없다.



### 유니크 인덱스 사용 시 주의사항

- 하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요가 없다.
- 또한 같은 컬럼에 대해 프라이머리 키와 유니크 인덱스를 중복해서 생성한 경우도 있는데, 이 역시 불필요하다.

<br>

## 4.5. 예상 질문

1. 데이터베이스 인덱스의 개념과 장점에 대해 설명해주세요.
2. 인덱스에 단점은 어떤 것들이 있을까요?
3. 인덱스를 관리하기 위한 자료구조로 어떤 것들이 있는지, 특징은 무엇인지 설명해주세요.
4. 해시 테이블 자료구조를 통해 인덱스를 관리하면 어떤 단점이 있을까요?
5. 인덱스를 효율적으로 활용하기 위해서 어떤 점들을 고려해볼 수 있을까요?
6. 인덱스가 있음에도 불구하고 그 효과를 제대로 발휘하지 못하는 상황에는 어떤 것들이 있을까요?
7. 커버링 인덱스의 개념과 장점에 대해 설명해주세요.
8. 클러스터링 인덱스의 개념에 대해 설명해주세요.
9. 프라이머리 키를 명시하지 않은 테이블에 대해서는 어떻게 클러스터링 인덱스를 구성하나요?
10. 클러스터링 인덱스의 단점에 대해 설명해주세요.
