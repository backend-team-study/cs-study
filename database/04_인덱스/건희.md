# 04 인덱스

# 1. 인덱스의 개념

인덱스는 테이블의 조회속도를 높여주는 자료구조이다. 책 뒷편의 ‘색인’과 동일한 역할을 한다. 인덱스는 MYI(MySQL Index)에 저장된다.

### 인덱스를 생성할 필드 선택 기준

- **검색 빈도**

  자주 검색되는 필드일수록 인덱스를 생성하는 것이 좋다.

- **카디널리티(Cardinality)**

  해당 필드의 고유한 값의 수가 많을수록 인덱스의 효과가 크다.

- **필터링과 정렬**

  WHERE 절에서 필터링이나 ORDER BY 절에서 정렬에 사용되는 필드는 인덱스를 생성하는 것이 유리하다.

### 단점

조회속도는 빨라지지만, UPDATE, INSERT, DELETE 속도는 저하된다는 단점이 있다. (Index 정보를 갱시하는 데에 추가적인 비용이 들기 때문)

> **멀티 컬럼 인덱스** 앞선 컬럼에 의존하는 정렬 순서실제 서비스를 할 때 인덱스 설계는 아주 중요하다.
>
> 실무에서는 주로 하나의 컬럼보다는 여러 개의 컬럼으로 인덱스를 만든다. (= 멀티 컬럼 인덱스 = 다중 컬럼 인덱스 = 복합 인덱스)
>
> 멀티 컬럼 인덱스에서 가장 중요한 특성은 정렬이다.
>
> 인덱스는 정렬된 순서라는 게 아주 중요한 특징인데, 멀티 컬럼 인덱스로 구성하게 되면 정렬이 앞선 컬럼에 의존하여 정렬된다.
>
> 쉽게 말하면 멀티 컬럼 인덱스를 생성할 때 앞에 있는 컬럼 순서대로 정렬이 된다는 것이다.
>
> 그렇기 때문에 인덱스의 순서를 아주 잘 고려해서 설계해야 한다.

# 2. 인덱스의 종류

## Clustered Index

- 테이블당 한개만 생성가능
- pk를 설정한 경우 default로 pk가 클러스터드 인덱스로 설정
- 인덱스 자체에 data가 저장되어 있음
- 실제 물리적인 정렬순서와 인덱스의 정렬순서와 같음

클러스터 인덱스는 영어사전과 닮았다. 이미 내용이 기준 컬럼으로 정렬되어 있다. 보통 테이블을 생성할 때 PK를 지정했다면 해당 컬럼에 자동적으로 클러스터 인덱스가 생성된다.

### 클러스터링 인덱스의 장점과 단점

- 장점
  - PK 기준의 검색 성능이 매우 빠름.
    - 특히 PK를 범위 검색하는 경우 매우 빠름
  - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있어서, 인덱스만으로 처리할 수 있는 경우가 많음.
- 단점
  - 테이블의 모든 세컨더리 인덱스가 PK를 갖기 때문에 PK 값이 차지하는 메모리가 클 경우에 전체적으로 인덱스의 메모리 크기가 커짐.
  - 세컨더리 인덱스를 통해서 검색할 때, PK 값을 알아낸 후 PK로 다시 한 번 검색해야 하므로 처리 성능이 느림.
  - INSERT 할 때, PK에 의해 레코드의 저장 위치가 결정되기 때문에 성능이 느림.
  - PK 키를 변경할 때, 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 성능이 느림.

### 클러스터링 인덱스 주의사항

- 클러스터링 인덱스인 PK의 메모리 크기 선정에 있어서 주의해야 함.
  - 클러스터링 인덱스가 될 PK는 모든 세컨더리 인덱스에 포함되기 때문에, PK가 차지하는 메모리 크기에 따라 세컨더리 인덱스의 메모리 크기는 기하급수적으로 증가함.
- PK는 명시적으로 작성한다.
  - PK를 직접 명시해서 DDL을 작성하지 않더라도, InnoDB 스토리지 엔진에서는 내부적으로 일련번호 칼럼을 추가함.
  - 하지만, 이 내부적인 일련번호는 접근할 수 없으므로, 비즈니스 상 PK가 존재하지 않는다면, AUTO_INCREMENT를 통해 인조 식별자를 생성하는 것을 권장함.

## Non-Clustered Index (Secondary Index)

보조 인덱스는 일반적인 책의 ‘색인’과 같다. 원하는 페이지로 바로 이동하는 것이 아니라 ‘색인’을 살펴본 후 해당 페이지로 이동하는 것. 보조 인덱스는 여러개 생성될 수 있다.

- Equal 검색 시에, 유니크 인덱스라면 검색 결과가 1개라는 것이 보장되기 때문에 SQL 옵티마이저에게 유니크 여부는 굉장히 중요한 문제

> 특정 테이블에 PK가 존재하면서 Unique Key 가 존재할 경우
>
> - PK로 지정된 컬럼은 클러스터드 인덱스가 된다.
> - Unique Key로 지정된 컬럼들은 보조 인덱스가 된다.
> - Unique Key로 지정된 컬럼의 NULL 허용 여부와 상관없이 모두 보조 인덱스가 된다.
>
> 특정 테이블에 PK가 존재하지 않고, Unique Not Null 제약이 지정될 경우
>
> - 해당 컬럼이 클러스터드 인덱스가 된다.
> - NOT NULL 조건이 없다면 보조 인덱스가 된다.

# 3. 인덱스 구조

## B-Tree 인덱스

최상위에 `루트노드`가 있고 가장 끝단에 실제 레코드의 주소가 저장되어있는 `리프노드`가 있다. 루트 노드와 리프 노드 사이에는 `브랜치 노드` 가 있다. 루트 노드와 브랜치 노드에는 실제 레코드의 주소는 알 수 없지만, 실제 레코드의 주소를 알고 있는 리프 노드에 대한 매핑 정보를 갖고 있다.

리프 노드들은 데이터가 순서대로 저장되어 있지 않는데, 데이터를 순서대로 생성하여 관리하더라도 도중에 데이터가 삭제되면 그 자리가 비워질 수박에 없고, 다시 데이터를 생성할 때 그 빈자리를 활용하기 때문이다.

## InnoDB의 인덱스 구조

위 B-Tree 인덱스와 전반적으로 비슷하지만 데이터 파일을 관리하는 게 다르다. `리프 노드`에 주소가 아닌 실제 값(PK)을 저장한다. B-Tree 인덱스에서는 데이터 파일이 순차적으로 있지 않고, 여러 위치에 뒤죽박죽 저장되어 있기 때문에 실제 레코드 수가 몇 개 되지 않더라도, 그것들이 다 다른 위치에 있다면 메모리로 읽어와야 할 페이지 수가 많아져 I/O 효율이 떨어지기 때문이다.

InnoDB의 인덱스는 데이터 파일에 저장 방식 자체를 **프라이머리 키 인덱스로 정렬하여** 관리하는 것으로 효율 문제를 해결했다.

또한, 리프 노드의 데이터들을 연결 리스트로 연결하여 정렬된 상태의 리프 노드를 순차 탐색을 할 수 있게 되었다.

## 해시 알고리즘

B-Tree가 아닌 해시 알고리즘을 통해 인덱스를 생성할 수도 있을 것이다. 해쉬 충돌이 일어나지 않는다면 O(1)의 시간 복잡도를 갖기 때문에 인덱스로 활용하기 상당히 좋은 알고리즘이라고 생각해볼 수 있기 때문이다. 하지만, 부등호 연산에 부적합하기 때문에 인덱싱 알고리즘으로는 잘 사용되지 않는다. 해시 테이블의 데이터는 정렬되어 있지 않으므로 비교 연산을 하기 위해서는 모든 데이터에 접근해야한다.