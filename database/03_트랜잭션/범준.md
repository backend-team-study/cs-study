# 03. 트랜잭션
> 고범준


### 트랜잭션 개념
트랜잭션(transaction)은 데이터베이스에서 하나의 논리적인 작업 단위를 의미합니다. 여러 개의 데이터베이스 연산을 포함할 수 있으며, 이들 연산은 하나의 트랜잭션에서 모두 성공적으로 수행되거나 모두 실패해야 합니다. 즉, 트랜잭션 내의 연산들은 부분적으로 완료되어서는 안 되고, 전체가 완전히 수행되거나 전혀 수행되지 않아야 합니다.

### ACID
ACID는 트랜잭션이 데이터베이스에서 안정적으로 수행되도록 보장하는 네 가지 주요 속성입니다.
- **Atomicity (원자성)**: 트랜잭션 내의 모든 연산은 하나의 단위로 처리되어야 하며, 모두 성공하거나 모두 실패해야 합니다.
- **Consistency (일관성)**: 트랜잭션 수행이 성공적으로 완료되면, 데이터베이스는 항상 일관된 상태를 유지해야 합니다.
- **Isolation (독립성)**: 동시에 여러 트랜잭션이 처리될 때, 각 트랜잭션은 다른 트랜잭션의 연산으로부터 독립되어야 합니다.
- **Durability (영속성)**: 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템의 장애가 발생하더라도 영구적으로 반영되어야 합니다.

### Commit, Rollback
- **Commit**: 트랜잭션이 성공적으로 끝나고 데이터베이스의 변경 사항을 실제 데이터베이스에 영구적으로 기록할 때 사용합니다.
- **Rollback**: 트랜잭션 중에 오류가 발생하거나 중단되면, 트랜잭션의 모든 연산을 취소하고 트랜잭션 이전 상태로 되돌립니다.

### 트랜잭션 격리수준
트랜잭션 격리수준(isolation level)은 다수의 트랜잭션이 동시에 수행될 때, 하나의 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않도록 보장하는 수준을 말합니다. 격리수준을 낮추면 성능은 향상되지만, 다양한 문제점들이 발생할 수 있습니다(예: 더티 리드, 논리적일관성 없는 읽기, 팬텀 리드 등).

### LOCK, 교착상태
- **LOCK**: 데이터베이스 시스템에서 동시성을 제어하기 위해 데이터 항목에 대한 접근을 제한하는 메커니즘입니다. LOCK은 데이터를 안정적으로 보호하지만, 부적절하게 사용될 경우 성능 저하를 가져올 수 있습니다.
- **교착상태(Deadlock)**: 두 개 이상의 트랜잭션이 서로의 작업이 끝나기를 기다리며, 영원히 대기 상태에 빠지는 것을 의미합니다. 이를 방지하고 해결하기 위해 데이터베이스


--- 
MySQL에서의 레코드락(Record Lock), 갭락(Gap Lock), 그리고 넥스트키락(Next-Key Lock)은 InnoDB 스토리지 엔진에서 사용하는 특정한 유형의 락(lock)입니다. 이 락들은 데이터의 동시성과 일관성을 유지하기 위해 사용되며, 특히 트랜잭션이 복잡하고 동시에 여러 작업이 이루어지는 환경에서 중요합니다.

### 레코드락 (Record Lock)
레코드락은 특정 레코드에 대한 락입니다. 이는 특정 행에 대한 읽기 또는 쓰기 작업을 보호하기 위해 사용됩니다. 특정 행을 처리하는 동안 다른 트랜잭션이 해당 행에 대한 변경을 시도할 수 없도록 합니다. 레코드락은 주로 Primary Key나 Unique Index가 있는 컬럼에 적용됩니다.

### 갭락 (Gap Lock)
갭락은 레코드와 레코드 사이, 또는 레코드와 인덱스 범위의 끝 부분과 같은 특정 범위에 적용되는 락입니다. 이러한 갭락은 다른 트랜잭션이 락이 걸린 범위 내에 새로운 레코드를 삽입하는 것을 방지합니다. 갭락은 특정 범위에 대한 팬텀 리드(phantom read)를 방지하는 데 사용되는데, 이는 격리 수준이 'REPEATABLE READ'인 경우에 주로 사용됩니다.

### 넥스트키락 (Next-Key Lock)
넥스트키락은 레코드락과 갭락을 결합한 것으로, 레코드 자체와 레코드 앞의 갭에 대한 락을 동시에 거는 것입니다. 이러한 락은 특정 레코드를 선택하고 해당 레코드 전후에 새로운 레코드가 삽입되는 것을 방지합니다. 넥스트키락은 InnoDB의 기본 격리 수준인 'REPEATABLE READ'에서 표준으로 사용되며, 'SERIALIZABLE' 격리 수준에서도 사용됩니다.

이러한 락은 데이터의 일관성과 동시성을 유지하는 데 중요하지만, 잘못 사용하거나 설계하면 성능 저하 및 데드락(교착상태)을 일으킬 수 있습니다. 따라서 적절한 인덱싱 전략과 함께 트랜잭션을 신중하게 설계하는 것이 중요합니다.

---

교착상태 감지 알고리즘

1. 자원 할당 그래프(Resource Allocation Graph) 방식
   자원 할당 그래프는 시스템의 자원 할당 상태를 그래프로 표현한 것으로, 프로세스와 자원을 각각 노드로, 각 노드 간의 엣지로 자원 요청 및 할당 상태를 나타냅니다. 이 그래프를 사용해 다음과 같이 교착상태를 감지할 수 있습니다:

노드: 프로세스 또는 자원을 나타냄
엣지:
할당 엣지(자원에서 프로세스로의 방향): 자원이 프로세스에게 할당됨
요청 엣지(프로세스에서 자원으로의 방향): 프로세스가 자원을 요청함
시스템은 주기적으로 또는 특정 조건에서 자원 할당 그래프를 검사하여 순환 구조를 찾습니다. 그래프에 순환 구조가 존재하면 그 구조 내의 프로세스들이 교착상태에 빠졌다고 판단합니다. 순환 구조가 없다면 교착상태는 없는 것으로 간주됩니다.

2. 은행원 알고리즘(Banker's Algorithm) 방식
   은행원 알고리즘은 여러 프로세스가 자원을 요청할 때 시스템이 안전한 상태를 유지할 수 있는지를 판단하는 알고리즘입니다. 이 알고리즘은 안전성 알고리즘과 자원 요청 알고리즘 두 부분으로 구성됩니다.

안전성 알고리즘: 시스템의 현재 상태가 안전한지 검사합니다. 모든 프로세스가 요구하는 최대 자원을 할당받을 수 있을 때만 시스템은 안전한 상태에 있다고 봅니다.
자원 요청 알고리즘: 프로세스가 자원을 요청할 때, 이 요청이 시스템을 안전한 상태로 유지할 수 있으면 요청을 승인합니다.
은행원 알고리즘은 주로 요청과 할당에 대한 자원의 가능한 조합을 통해 시스템이 안전한 상태로 남을 수 있는지 여부를 판단하여 교착상태를 예방하는 데 사용됩니다.

교착상태 해결
교착상태 감지 후에는 다음과 같은 방법으로 해결할 수 있습니다:

자원을 강제로 회수: 교착상태를 일으킨 프로세스 중 하나 이상에서 자원을 강제로 회수합니다.
프로세스 중지: 교착상태의 원인이 되는 프로세스 중 하나 이상을 중지합니다.
기아 상태 고려: 자원을 회수하거나 프로세스를 중지할 때 기아 상태가 발생하지 않도록 주의해야 합니다.
