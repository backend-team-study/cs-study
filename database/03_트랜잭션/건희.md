# 03 트랜잭션

# 트랜잭션 (Transaction) 이란?

트랜잭션의 사전적 의미는 `거래`이고, 컴퓨터 과학 분야에서의 트랜잭션은 `더 이상 분할이 불가능한 업무처리의 단위`를 의미한다.

이것은 하나의 작업을 위해 더 이상 분할할 수 없는 명령들의 모음, 즉 한꺼번에 수행되어야 할 일련의 연산 집합을 의미한다.

> **예시**
>
> 계좌에서 돈을 꺼내는 인출 과정과 돈을 넣은 입금 과정에서 인출만 성공하고 입금에는 실패한다면 치명적인 결과가 나오기 때문에 이 두 과정은 동시에 성공하던지 동시에 실패해야 한다 → 하나의 묶음으로써 `Atomic` 함을 의미한다

데이터 베이스와 애플리케이션의 데이터 거래(Transaction)에 있어서 안정성을 확보하기 위한 방법이 `트랜잭션`인 것이다.

따라서 데이터 베이스에서 테이블의 데이터를 읽어 온 후 다른 테이블에 데이터를 입력하거나 갱신, 삭제하는 도중에 오류가 발생하면 결과를 재반영 하는 것이 아니라 모든 작업을 원상태로 복구하고, 처리 과정이 `모두 성공하였을 때만 그 결과를 반영한다.`

# 트랜잭션 특징

## 원자성 (Atomic)

원자성은 트랜잭션이 `데이터 베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것`이다.

트랜잭션은 사람이 설계한 논리적인 작업 단위로서, 일처리는 작업단위 별로 이루어져야 사람이 다루는데 무리가 없다.

만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람은 데이터 처리 시스템을 이해하기 힘들 뿐만 아니라 오작동 했을시 원인을 찾기가 매우 힘들어질 것이다.

## 일관성 (Consistency) ?

일관성은 `트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것`이다.

트랜잭션이 진행되는 동안에 데이터 베이스가 변경 되더라도 업데이트된 데이터 베이스로 트랜잭션이 진행되는 것이 아니라, 처음에 트랜잭션을 진행하기 위해 참조한 데이터 베이스로 진행된다.

이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있는 것이다.

## 독립성 (Isolation)

독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 `연산에 끼어들 수 없다는 점`을 가리킨다.

하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

- 이는 독립성의 수준에 따라 다르다.

## 영구성 (Durability)

지속성은 트랜잭션 성공적으로 완료됐을 경우, 결과는 영구적으로 반영되어야 한다.

# 트랜잭션 상태

트랜잭션의 개념은 서술한 바와 같이 데이터 베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 혹은 데이터 베이스 시스템에서 복구 및 병행 수행시 처리되는 작업의 논리적 단위이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/240b8a95-4793-40aa-afcd-383fb3e11370/48662c9b-38af-4491-990f-6f1c45092125/Untitled.png)

트랜잭션의 연산과정의 단계를 도식화하고 각각의 단계의 상태를 그림과 같이 정리할 수 있다.

### Q 활성 상태란?

트랜잭션이 정상적으로 실행 중인 상태를 의미합니다. 트랜잭션이 시작되면, 해당 트랜잭션의 상태는 활동 상태가 됩니다. 활동 상태는 설계자가 설계한 대로 연산들이 실행중인 상태를 의미합니다.

### Q 활성 상태에서 작업 성공시에는 어떤 상태가 되나요?

1. 부분 완료 (Partially Committed) : 트랜잭션의 마지막까지 (작업의 마지막) 실행되었지만, Commit이 되진 않은 상태입니다.
2. 완료 (Committed) : 트랜잭션이 성공적으로 종료되어 `Commit` 연산을 실행한 후의 상태입니다.

설계된 작업대로 작업이 성공하였다고 무조건 반영하는 것이 아니라, 설계자의 최종 승인(Commit)이 있을 때까지 실제 데이터 베이스(디스크)에 작업 내용을 반영하지 않고 기다리고 있는 상태 (메모리 버퍼에서 대기?) 입니다.

### Q 작업 실패시에는 어떤 상태가 되나요?

1. 실패 (Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태가 됩니다.
2. 철회 (Aborted) : 트랜잭션이 비정상적으로 종료되어 `Rollback`연산을 수행한 상태가 됩니다.

트랜잭션을 수행하는 중간에 모종의 원인으로 인하여 발생하여 실행이 중단된 상태를 실패 상태라고 한다. 이때 트랜잭션이 비정상적으로 종료되었으니, 설계되어있는 트랜잭션 내부의 작업을 다시 수행 이전의 상태로 돌리는 롤백 연산을 수행하면, 그 상태를 철회라고 한다.

# 트랜잭션 격리수준

## SERIALIZABLE

SERIALIZABLE (이하 **시리**) 는 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다. 시리에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다. 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어진다.

MySQL에서 `select for share/update` 대상 레코드에 각각 읽기/쓰기 잠금을 거는 것이다. **시리**에서는 순수한 `select` 작업에서도 대상 레코드에 `넥스트 키 락`을 읽기 잠금(공유락, Shared Lock)으로 건다. 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다. 시리는 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안되겠다.

> SERIALIZABLE 에서의 데드락 정리하기

# REPEATABLE READ

일반적인 RDBMS는 변경 전의 레코드를 UNDO 공간에 백업해둔다. 그러면 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여 이를 `MVCC(Multi-Version-Concurrency-Control, 다중 버전 동시성 제어)` 라고 부른다. MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다. 각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, `백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장`한다. 그리고 해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 백그라운드 쓰레드를 통해 삭제한다.

REPETABLE READ는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있다. 이러한 상황을 `Phantom Read`라고 하는데, MVCC 덕분에 일반적인 조회에서는 일어나지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하고 UNDO 로그를 읽기 때문이다.

> 일반적으로 MySQL 에서는 팬텀 리드가 발생하기 힘들다
>
> - SELECT FOR UPDATE 이후 SELECT: 갭락 때문에 팬텀리드 X
> - SELECT FOR UPDATE 이후 SELECT FOR UPDATE: 갭락 때문에 팬텀리드 X
> - SELECT 이후 SELECT: MVCC 때문에 팬텀리드 X
> - SELECT 이후 SELECT FOR UPDATE: 팬텀 리드 O

## READ COMMITTED

커밋된 데이터만 조회할 수 있다. Phantom Read에 더해 `Non-Repeatable Read` (반복 읽기 불가능) 문제까지 발생한다.

A 트랜잭션에서 “건희”를 조회했을 때는 정상적으로 결과가 반환되었다고 가정하고, B 트랜잭션에 “건희”를 삭제하고 커밋한다면, READ COMMITTED 단계에서는 커밋된 변경사항을 읽을 수 있기 때문에 A 트랜잭션에서 다시 “건희”를 조회하면 아무런 값도 나오지 않게 된다. 이렇게 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있는데, 이러한 데이터 부정합 문제를 Non-Repeatable Read 라고 한다.

## READ UNCOMMITTED

커밋하지 않은 데이터 조차도 접근할 수 있다.

## 정리

|                 | Dirty Read | Non-Repeatable Read | Phantom Read            |
| --------------- | ---------- | ------------------- | ----------------------- |
| READ UNCOMMITED | 발생       | 발생                | 발생                    |
| READ COMMITTED  | 없음       | 발생                | 발생                    |
| REPEATABLE READ | 없음       | 없음                | 발생(MySQL은 거의 없음) |
| SERIALIZABLE    | 없음       | 없음                | 없음                    |

# LOCK

MySQL에서 사용되는 락은 크게 `스토리 엔진 레벨` 과 `MySQL 엔진 레벨` 로 나눌 수 있다. 스토리 엔진 레벨의 잠금은 테이블이나 데이터 베이스 등과 같은 부분을 위한 락에 해당한다.

스토리지 엔진 레벨의 잠금에는 다음과 같은 락들이 존재한다.

- 레코드 락 (Recored Lock)
- 갭 락 (Gap Lock)
- 넥스트 키 락 (Next Key Lock)
- 자동 증가 락 (Auto Increment Lock)

MySQL 엔진 레벨의 잠금에는 다음과 같은 락들이 존재한다.

- 공유 락 (Sahred Lock) - 읽기 잠금
- 베타 락 (Exclusive Lock) - 쓰기 잠금
- 글로벌 락 (Global Lock)
- 테이블 락 (Table Lock)
- 네임드 락 (Named Lock)
- 메타데이터 락 (Meta Data Lock)

락 적용 요소에 대한 분류 (s-lock, x-lock, Intention Lock) vs 락 적용 상황에 대한 분류

## 레코드 락

일반적으로 레코드 락은 `테이블 레코드 자체를 잠그는 락`을 의미한다. 레코드 수준의 잠금은 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다. 하지만, `MySQL에서의 레코드 락은 테이블의 레코드가 아닌 인덱스의 레코드를 잠근다는 점에서 중요한 차이가 있다`.

별도로 인덱스를 지정해주지 않아도 자체적으로 인덱스를 생성하고 해당 인덱스에 락이 걸린다

> 자체적으로 인덱스를 만들어 버리면 무조건 인덱스를 타야 하는 건가?
>
> 인덱스를 만들면 입력, 수정, 삭제의 속도가 느려지는데..

## 갭 락

인덱스 범위 조건 중에서 실제 레코드를 제외하고, 데이터가 추가될 수 있는 범위에 걸리는 락으로, 데이터의 삽입, 수정, 삭제를 제어한다.

## 넥스트 키 락

레코드 락과 갭 락을 합친 것으로, 갭 락은 단독으로 사용되기 보다는 넥스트 키 락의 일부로 함께 사용된다. 해당 레코드 뿐만 아니라 인접 레코드와의 간격에도 잠금을 걸게 된다. 넥스트키락은 InnoDB의 기본 격리 수준인 '`REPEATABLE READ`'에서 표준으로 사용되며, `'SERIALIZABLE`' 격리 수준에서도 사용된다.

# 교착상태 (Deadlock)

멀티 트랜잭션 간 교착 상태를 의미한다. 동일한 자원을 공유하고 있는 2개 이상의 트랜잭션이 자신들의 작업을 진행하기 위해 사용해야 하는 리소스를 서로 미리 선점함으로써 상대방이 자원에 접근하는 것을 방해함으로써 트랜잭션의 동작이 멈추기 때문에 데드락이라고 한다.

## 교착 상태 해결 방법

1. `타임 아웃` 설정하기 : 일정 시간 동안 트랜잭션이 실행되지 않는 경우 롤백 처리한다.

2. 데이터 접근 순서 설정하기

3. `wait - die` 또는 `wound - wait` : 타임 스탬프를 사용해서, 트랜잭션 생성 시기로 선점 여부를 결정하는 방식이다.

   `wait -die`: 트랜잭션 A가 B의 락킹된 데이터를 요청할 때 A가 먼저 들어온 트랜잭션이라면 대기한다. A가 나중에 들어온 트랜잭션이라면 포기(die)하고 나중에 다시 요청한다.

   `wound - wait` : 트랜잭션 A가 B의 락킹된 데이터를 요청할 때 A가 먼저 들어온 트랜잭션이라면 선점(wound)한다. A가 나중에 들어온 트랜잭션이라면 대기한다.