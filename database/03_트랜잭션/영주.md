# 03. 트랜잭션
> 김영주

## 3.1. 트랜잭션

> 트랜잭션(Transaction)이란, 하나의 작업을 수행하는 데 필요한 데이터베이스의 연산들을 모아놓은 것이다.

- 데이터베이스의 논리적 작업 단위가 된다.
- 장애가 발생했을 때 데이터를 복구하는 작업의 단위가 된다.
- 작업 수행에 필요한 SQL 문들의 모임이다.

<br>

## 3.2. ACID

> 트랜잭션의 네 가지 주요 특성

- `원자성(Atomicity)` : 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나, 하나도 실행되지 않아야 한다. (all or nothing)
  - 원자성을 보장하기 위해 DBMS는 `회복` 기능을 제공한다.
- `일관성(Consistency)` : 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 한다.
  - 원자성을 보장하기 위해 DBMS는 `병행 제어` 기능을 제공한다.
- `격리성(Isolation)` : 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없다.
  - 원자성을 보장하기 위해 DBMS는 `병행 제어` 기능을 제공한다.
- `지속성(Durability)` : 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다.
  - 원자성을 보장하기 위해 DBMS는 `회복` 기능을 제공한다.

<br>

## 3.3. COMMIT / ROLLBACK

> 트랜잭션의 수행과 관련하여 주로 사용되는 두 가지 연산

- `COMMIT` 연산 : 트랜잭션이 성공적으로 수행되었음을 선언 (작업 완료)
  - commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 데이터베이스에 반영된다.
- `ROLLBACK` 연산 : 트랜잭션을 수행하는 데 실패하였음을 선언 (작업 취소)
  - rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션이 수행되기 전의 상태로 돌아간다.



- 트랜잭션의 상태

  ![image](https://github.com/dev-team-study/cs-study/assets/49775540/944a08c7-9ebd-41b8-9574-33baa464dc1a)

  - `활동 상태` : 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태
  - `부분 완료 상태` : 트랜잭션의 마지막 연산이 실행된 직후의 상태 (연산은 끝났는데, 아직 데이터베이스에 반영이 안된 상태)
  - `완료 상태` : 트랜잭션이 성공적으로 완료되어 commit 된 상태
  - `실패 상태` : 장애가 발생하여 트랜잭션 수행이 중단된 상태
  - `철회 상태` : 실패 상태 이후 rollback 하여 트랜잭션 이전의 상태로 복구한 상태

<br>

## 3.4. 장애와 회복

데이터베이스는 기본적으로 아래와 같이 응용 프로그램과 메인 메모리, 그리고 디스크 간의 연산이 일어난다.

![image](https://github.com/dev-team-study/cs-study/assets/49775540/49ac27d8-be70-4168-b917-f4df9a1325f5)



**회복(Recovery)**이란, 데이터베이스에 장애가 발생했을 때 장애가 발생하기 전의 모순이 없고 일관된 상태로 복구시키는 것을 말한다.

- `덤프(dump)` : 데이터베이스 전체를 하루에 한 번 혹은 한달에 한 번과 같이 정해진 주기에 따라 다른 저장 장치에 복사하는 방법
- `로그(log)` : 변경 연산이 실행될 때마다 변경 이전 값과 이후 값을 별도의 파일에 기록하는 방법
  - `redo log (재실행 로그)` : 전반적으로 손상된 경우에 사용하며, 가장 최근에 저장한 복사본을 가져와 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 복구한다.
  - `undo log (취소 로그)` : 변경 중이었거나, 변경된 내용만 신뢰성을 잃은 경우에 사용하며, 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 원래의 상태로 복구한다.



<br>

## 3.5. 격리수준

`격리수준(Isolation Level)`이란, 다수의 트랜잭션이 동시에 처리될 때, 한 트랜잭션이 다른 트랜잭션의 변경 데이터를 볼 수 있게 허용하는지의 여부를 결정하는 수준을 말한다.

<img width="930" alt="image" src="https://github.com/dev-team-study/cs-study/assets/49775540/cccbd066-35f3-4aac-a831-a395df513875">

- READ UNCOMMITED
  - 가장 낮은 격리 수준
  - 아직 커밋하지 않은 데이터 조차도 볼 수 있는 격리 수준이다.
  - 다른 트랜잭션의 작업이 commit 혹은 rollback 되지 않아도 즉시 보인다.
- READ COMMITED
  - 커밋된 데이터만 볼 수 있는 격리 수준이다.
- REPEATABLE READ
  - 트랜잭션 번호를 참고하여, 자신보다 먼저 실행된 트랜잭션의 데이터만을 조회한다.
  - 데이터를 읽어올 때 언두 로그에 저장된 기존 데이터를 가져와 보여주는 격리 수준이다.

- SERIALIZABLE
  - 가장 엄격한 격리 수준
  - 트랜잭션을 순차적으로 진행시키는 격리 수준이다.
  - 여러 트랜잭션이 동일한 데이터에 동시 접근이 불가능 하여, 어떠한 데이터 부정합 문제도 발생하지 않는다.
  - 순차적 실행으로 인해 성능상 단점이 있다.



<br>

## 3.6. Lock

### 동시성 문제

DBMS는 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 병행 수행을 지원한다.

병행 수행되는 트랜잭션들이 동시에 같은 데이터에 접근하여 변경 연산을 실행하려고 하면 예상치 못한 결과가 나타난다. (동시성 문제)

- `갱신 분실(Lost update)` : 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것을 말한다.
- `모순성(Inconsistency)` : 하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행하여 모순이 발생하는 것을 말한다.
- `연쇄 복귀(Cascading Rollback)` : 트랜잭션이 완료되기 전 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것을 말한다.



### 병행 제어와 Lock

이러한 병행 수행 과정에서의 동시성 문제를 해결하기 위해 DBMS는 병행 제어 기법을 따로 마련했다.

병행 제어 기법 중 가장 많이 사용되는 방식은 Lock을 이용한 잠금 방식이다.

- `잠금(Locking) 기법`이란, 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어하는 것을 말한다.
- 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 다른 트랜잭션이 접근하지 못하도록 상호 배제(Mutual Exclusion)한다.
- 잠금 단위는 데이터베이스 전체에서부터 작게는 속성에 이르기까지 다양하다. 단위가 커질수록 병행성은 낮아지지만 제어가 쉽고, 단위가 작아질수록 제어가 어렵지만 병행성은 높아진다.



데이터를 변경시키는 write 연산에 대해서는 독점권을 가져야 하지만, 데이터를 단순히 읽는 read 연산에 대해서는 동시에 실행해도 문제가 되지 않는다.

따라서 아래와 같이 같은 데이터에 트랜잭션들이 read 연산을 동시에 실행할 수 있도록 Lock을 구분한다.

- `공유락(Shared Lock)` : 한 트랜잭션이 데이터에 대해 공유락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수 있지만 write는 할 수 없다. 그리고 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락을 가질 수 있다.
- `배타락(Exclusive Lock)` : 한 트랜잭션이 데이터에 대해 배타락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수도, write 할 수도 없다. 그리도 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락, 배타락을 모두 가질 수 없다.



### Lock의 한계

공유락과 배타락을 이용해도 lock과 unlock의 시점에 따라 두 트랜잭션은 모순된 결과를 생성할 수 있다. (기본 잠금 규약의 한계)

따라서 **2단계 잠금 규약(2 Phase Locking Protocol, 2PLP)**을 통해 lock과 unlock을 2단계로 나누어 실행해야 한다.

- `확장 단계` : 트랜잭션이 lock 연산만 실행 가능하고, unlock 연산은 실행할 수 없는 단계
- `축소 단계` : 트랜잭션이 unlock 연산만 실행 가능하고, lock 연산은 실행할 수 없는 단계

그러면 한 트랜잭션이 lock을 시작하면 연산이 이루어지는 모든 데이터에 대해 unlock이 아닌 lock 연산을 할 수 밖에 없으므로(확장 단계)

다른 트랜잭션은 먼저 실행된 트랜잭션이 데이터를 unlock 하는 경우(축소 단계 경우)에만 이미 write가 끝난 데이터를 가져와 lock을 걸고 연산할 수 있게된다.

그래서 직렬 가능성이 항상 보장된다.



2단계 잠금 규약을 적용하면 트랜잭션의 직렬 가능성을 보장할 수는 있으나, 교착 상태(DeadLock)이 발생할 수 있다.

교착 상태란, 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 트랜잭션 수행을 중단하고 있는 상태를 말한다.

이때는 트랜잭션이 더이상의 연산을 실행하지 못하고 한없이 기다리게 된다.
