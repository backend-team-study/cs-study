# 05 Replication / Partioning / Sharding

# 1. 복제 (Replication)

복제는 1개 이상의 레플리카 저장소 (slave) 가 소스 저장소 (master)와 동기화를 자동으로 유지하는 과정이다.

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/Q5uBY/btrF4fi3idc/5z7ekcqynU7cb7q0kEBXrk/img.png

## 복제의 장점

- 스케일 아웃(Scale-out)
  - 사용자가 늘어남에 따라 커지는 트래픽으로 인한 DB 서버의 부하를 분산할 수 있다.
  - 갑자기 늘어나는 트래픽에도 유연하게 대처할 수 있다.
- 데이터 백업
  - 의도치않게 데이터가 삭제되면 백업을 진행하게 된다.
  - 동일한 서버 내에서 백업이 실행되는 경우 DB서버의 부하가 크게 발생한다.
  - 데이터 백업을 레플리카 서버에서 실행한다.
- 데이터 분석
  - 서비스에서 사용되는 쿼리가 아닌 차세대 비즈니스 모델 발굴을 위해 분석용 쿼리를 실행하기도 한다.
  - 대량 데이터 조회 및 집계 연산도 많기 때문에 실제 DB 서버에는 부하가 없도록 한다.
  - 여분의 레플리카 서버를 분석용 쿼리 전용으로 사용할 수 있다.
- 데이터의 지리적 분산
  - 서비스에서 사용되는 애플리케이션 서버가 DB 서버와 장거리로 떨어져있을 수도 있다.
  - 이 경우 두 서버의 통신 시간은 거리에 비례한다.
  - 애플리케이션 서버와 가까운 위치에 레플리카 서버를 구축해서 응답 시간을 개선한다.
- 소스 서버가 문제가 생겼을 때 대체 서버의 역할을 한다.

> 그러나 MySQL Replication 은 `비동기 방식`으로 진행되기 때문에 슬레이브로 복사 되는 시간을 온전히 기다려주지 않는다. 때문에 데이터가 완벽하게 복사가 되지 않을 수도 있다는 단점이 존재한다.

# MSR

일반적으로는 Master DB 즉 Source DB에 Slave DB가 여럿 붙게 됩니다. 따라서 쓰기 동작을 하는 DB는 하나만 존재하게 된다.

이때 일반적으로 쓰기 작업의 부하 분산을 위해서 샤딩을 하게 된다. (이번 글에서는 다루지 않는다.)

MySQL에서는 쓰기의 부하 분산을 위해 **Multi Source Replication (MSR)**을 지원한다.

!https://blog.kakaocdn.net/dn/ONSAD/btrGHl9Ry8T/Kv6gpE2dS8pnO5RwbMHPU0/img.png

MSR을 사용하면 DB 1번과 DB2번에 각각 데이터를 저장하고, 조회는 한 번에 Slave에서 할 수 있다.

## MySQL 복제 동작 과정

!https://velog.velcdn.com/images/mooh2jj/post/8e623bea-c1f4-42ac-9658-846af3d04fd4/image.png

1. 클라이언트가 `Insert/Update/Delete` 을 누르면 먼저 Master 서버에 존재하는 `Binary log` 에 변경사항을 모두 기록합니다.
2. Master Thread 는 비동기적 으로(복사되는 시간을 기다려주지 않습니다.) `Binary log를 읽어 Slave 서버로 전송`합니다.
3. Slave 의 `I/O Thread` 는 Master로 부터 받은 변경 데이터들을 `Relay log 에 기록`을 합니다.
4. Slave의 `SQL Thread` 는 Replay log의 기록들을 읽어 자신의 `스토리지 엔진에 최종 적용`합니다.

- `I/O Thread` 와 `SQL Thread` 는 슬레이브에만 존재한다
- 마스터에게는 `Binary Log Dum Thread`가 존재한다. (슬레이브에게 binary log 이벤트를 보내주는 스레드)

> `Binary Log`란?
>
> binary log 는 binlog 라고도 부른다. MySQL에서 발생하는 모든 내역을 기록하는 Log File이며, 이것은 기본적으로 비활성화되어 있는데, `conf` 파일에서 수정하여 이를 활성화 시켜주어야 한다.

> `Relay Log`란?
>
> 슬레이브는 `I/O Thread`를 통해서 받은 이벤트를 로컬에 있는 file에 저장한다. 이를 relay log라고 부른다. 보통 realy log는 `SQL Thread`가 이벤트를 읽고 나면 지운다.

## 주의 사항

- 호환성을 위해 Replication 을 이용하는 모든 DBMS는 동일한 환경으로 구성하는 것을 추천!
- Replication을 이용하는 DBMS Version이 각기 다른 경우 슬레이브 서버가 마스터 서버보다 상위 `version` 이어야 한다.
- Replication 적용 시 마스터 서버부터 올리고 슬레이브 서버를 올려야 한다.
- 지속적인 Replication 이용은 많은 Binary Log가 쌓이게끔 한다. 이는 결국 Storage 용량을 잡아먹는 원인이 된다. 때문에 `Cron`을 이용해서 정리를 주기적으로 하거나, `my.cnf`에 `expire_logs_day` 에 Log에 대한 유효기간을 지정해 주어야 한다.
- Replication 과정에서 에러가 발생하면 슬레이브는 Error Log를 작성하게 된다. 나중에 서버 관리자 등이 에러를 추적하여 Binary Log를 분석하여 유실된 자료를 복구할 수 있다.

# 2. 파티셔닝 (Partioning)

파티셔닝이란 데이터 베이스를 여러 부분으로 분할하는 것이다. 하나의 DBMS에 너무큰 테이블이 들어가면서 용량과 성능 측면에서 이슈가 발생할 때 파티셔닝 기법을 이용해 해결할 수 있다. 즉, 파티셔닝은 큰 테이블이나 인덱스를 작은 파티션 단위로 나누어 관리하는 기법을 뜻한다.

## 장점

1. 성능

- Query의 성능 향상 (적용된 부분에 따라 다름)
- 대용량 쓰기에 환경에서 효율적
- 필요한 데이터만 빠르게 조회할 수 있으므로 Query가 가벼워짐
- Full Scan에서 데이터 접근 범위를 줄여 성능 향상

1. 가용성

- 물리적인 파티셔닝 → 데이터의 훼손 가능성이 줄어듬
- 파티션 별로 독립적으로 백업하고 복구 가능
- 파티션 단위로 I/O 를 분산하여 경합을 줄이므로 UPDATE 성능 향상

1. 관리 용이성

- 큰 테이블을 제거하여 관리를 쉽게 할 수 있다.

## 단점

파티셔닝은 테이블을 여러 파티션으로 쪼개기 때문에 테이블 간의 `Join`비용이 증가한다. 또한 테이블과 인덱스를 별도로 파티셔닝 할 수 없기 때문에 테이블과 인덱스를 같이 파티셔닝해야 한다는 단점도 존재한다.

## 파티셔닝의 종류

### 1. 수평 파티셔닝

수평 파티셔닝은 하나의 테이블의 각 레코드를 다른 테이블에 분산시키는 것. 예를 들어 5개의 레코드를 갖는 테이블을 각각 3개, 2개의 레코드를 가진 테이블로 분산시키는 것.

### 장점

- 데이터의 개수와 인덱스의 개수가 줄어들어 성능이 향상된다.

### 단점

- 데이터를 찾는 과정이 기존보다 복잡하다.

> **샤딩 (Sharding)**
>
> 샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 기법을 뜻한다. 종종 샤딩과 수평 파티셔닝이 같은 의미로 사용되곤 하지만, 실은 좀 다르다.
>
> 수평 파티셔닝은 `같은 데이터 베이스 내`에서 하나의 큰 테이블을 쪼개 분산 저장하는 기법이다. 반면, 샤딩은 하나의 큰 테이블을 쪼개 각각 `다른 데이터베이스`에 분산 저장하는 기법이다.
>
> 이러한 샤딩은 수평 파티셔닝의 장점을 모두 갖지만, 데이터 베이스 서버 간의 연결 과정이 많아져 비용이 증가할 수 있으며, 분산된 서버 중에서 고장이 발생하면 데이터 정합성이 깨질 수 있다는 단점도 있다.

## 수직 파티셔닝

수직 파티셔닝은 테이블의 일부 열을 빼내는 형태로 분할한다. 즉, 테이블의 칼럼을 기준으로 나누어 파티셔닝을 한다. 정규화도 수직 파티셔닝과 관련된 과정이라고 할 수 있다. 하지만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정이라고 생각해야 한다.

### 장점

- 자주 사용하는 칼럼을 분리하여 성능을 향상시킬 수 있다.
- 같은 타입의 데이터가 저장되어 데이터 압축률을 높일 수 있다
- 조회 시 필요 없는 컬럼을 조회하지 않아도 되므로 성능상의 이점이 있다.

### 단점

- 데이터를 찾는 과정이 기본보다 복잡하다.

## 파티셔닝 분할 기준

**파티션 종류로는 범위(Range), 목록(List), 해시(Hash), 합성(Composite) 파티션이 있다**.

가장 널리 이용하는 `범위 분할` 은 주로 날짜를 기준으로 하는 경우가 많다. 이 경우 데이터가 균등하게 나누어져서 비슷한 성능 개선을 보장한다. 또한 보관 주기에 따라서 필요치 않는 데이터도 쉽게 지우고 관리할 수 있다.

분류가 가능한 PK 컬럼을 이용한 `목록 분할`도 많이 사용한다.

### 요약

테이블의 컬럼 개수와 데이터 양을 종합적으로 판단하여 양에 따른 대용량 테이블인지 판단 한다. 만약 컬럼 개수에 따른 것이라면 수직 분할을 적용, 양에 따른 것이라면 수평 분할을 적용

# Ref

- https://blog.seulgi.kim/2015/05/how-mysql-replication.html