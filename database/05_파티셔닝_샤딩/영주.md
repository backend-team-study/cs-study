# 05. 파티셔닝, 샤딩
> 김영주



## 5.1. 파티셔닝(Partitioning)

### 개념 및 특징

**개념**

- 하나의 테이블을 `파티션(Partition)`이라는 작은 단위로 분할하여 관리하는 방법이다.
- DB에 데이터가 너무 큰 테이블이 들어가면서 발생하는 용량과 성능 이슈를 해결하기 위해 등장하였다.
  (하나의 테이블에 데이터가 많을수록 인덱스도 같이 커지므로 용량 문제가 더 심해짐)



**특징**

- 테이블의 모든 데이터와 인덱스에 적용된다. 데이터나 인덱스 중 하나만 분할하는 것은 불가능하다.
- 물리적인 데이터 분할이 있지만, 애플리케이션 입장에서는 이를 인식하지 못한다. (논리적으로는 하나, 물리적으로는 여러 개로 관리)
- MySQL 8.0은 InnoDB, NDB 이외의 스토리지 엔진에서는 파티셔닝 기능을 제공하지 않는다.
- MySQL 8.0에서는 Partition key로 PK과 Unique Key를 모두 포함해야 한다. PK만으로 사용할 수 없다.
- InnoDB 기준 파티셔닝에서는 외래키를 지원하지 않는다. 따라서 외래키가 있는 테이블은 분할 할 수 없다.



### 장점과 단점

**장점**

1. 성능 관점

   - 테이블 풀스캔에서 데이터 조회 범위를 줄여 성능 향상을 가져온다. (자주 사용되는 데이터를 별도의 파티션으로 분리하면 더 좋음)

   - 파티션 단위로 디스크 I/O를 분산하므로 INSERT, UPDATE 성능이 향상된다.
   - 파티션 프루닝(Partition Pruning)을 통해, 옵티마이저가 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제시킨다. 이로써 조회 성능이 향상된다.

2. 데이터 가용성 관점

   - 물리적 분할로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.

   - 단일 디스크나 파일 시스템에 저장하는 것보다 더 많은 데이터를 하나의 테이블에 저장할 수 있다.

3. 관리 용이성 관점
   - 각 파티션을 독립적으로 백업하고 복구할 수 있다.
   - 로그성 데이터의 경우, 불필요해지면 파티션 단위로 삭제하여 간단하고 빠르게 처리할 수 있다. 
     (하나의 테이블에서 기간이 지난 로그성 데이터를 delete 연산하는 것보다, 기간이 지난 데이터가 모인 파티션을 drop하는 것이 성능상 이점이 있음)



**단점**

- 테이블 간 조인 비용이 증가한다.
- 테이블과 인덱스 중 하나만 파티셔닝 할 수 없다. 반드시 둘은 같이 파티셔닝 된다.
- 모든 파티션을 스캔하고, 각 파티션 별로도 테이블 스캔을 하는 쿼리가 많은 경우 오히려 성능이 떨어진다. (파티셔닝의 이점을 아예 못가져 가는 경우)



### 수평 파티셔닝

![image](https://github.com/backend-team-study/cs-study/assets/49775540/21504b63-a057-4dea-9a13-41e5a037c99a)

- 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것을 말한다.
- 동일한 스키마의 두 개 이상의 테이블에 데이터를 나누어 저장한다.



**파티셔닝 기준**

> 파티션 키를 정하는 기준

- **범위 분할 (Range Partitioning)**

  - 지정된 범위 내에 속하는 컬럼 값을 기준으로 행을 파티션에 할당한다.
  - 보통 날짜 기준으로 분할한다.

  ```sql
  CREATE TABLE test (
      id INT NOT NULL,
      lname VARCHAR(30),
      datt DATE NOT NULL DEFAULT '2000-01-01',
      separated DATE NOT NULL DEFAULT '9999-12-31',
      store_id INT NOT NULL
  ) PARTITION BY RANGE (YEAR(datt)) (
      PARTITION p0 VALUES LESS THAN (2020) ,
      PARTITION p1 VALUES LESS THAN (2021) ,
      PARTITION p2 VALUES LESS THAN (2022) ,
      PARTITION p3 VALUES LESS THAN MAXVALUE
  );
  ```

  

- **목록 분할 (List Partitioning)**

  - 범위 분할 방식과 비슷하지만, 특정 값을 기반으로 파티션에 할당한다.

  ```sql
  CREATE TABLE test (
      id INT NOT NULL,
      name VARCHAR(30),
      datt DATE NOT NULL DEFAULT '2000-01-01',
      separated DATE NOT NULL DEFAULT '9999-12-31',
      job_code INT NOT NULL,
      store_id INT NOT NULL
  ) PARTITION BY LIST (job_code) (
      PARTITION p0 VALUES IN (2) ,
      PARTITION p1 VALUES IN (1,9) ,
      PARTITION p2 VALUES IN (3,6,7) ,
      PARTITION p3 VALUES IN (4,5,8, NULL)
  );
  ```

  

- **해시 분할 (Hash Partitioning)**

  - 해시 함수에 의해 저장될 파티션을 결정한다.
  - 특정 범위나 값으로 나누기 어렵지만 파티션을 사용해야 하는 경우 사용한다.
  - 해시 함수를 어떻게 지정하느냐에 따라 파티션에 균등하게 할당하는 정도가 달라진다. (신중히 고려)

  ```sql
  CREATE TABLE test (
      id INT NOT NULL,
      name VARCHAR(30),
      datt DATE NOT NULL DEFAULT '2000-01-01',
      separated DATE NOT NULL DEFAULT '9999-12-31',
      job_code INT NOT NULL,
      store_id INT NOT NULL
  ) PARTITION BY HASH (id)
  PARTITIONS 4;
  ```

  

- **키 분할 (Key Partitioning)**

  - 해시 분할과 거의 비슷하다.
  - 단, 해시 분할은 사용자가 지정한 해시 함수를 사용했다면, 키 분할은 MySQL에서 제공하는 해시 함수를 사용한다는 차이가 있다.
  - 기본적으로 NDB는 MD5()를 사용하고, MySQL server는 내장된 해시 함수를 사용한다.



### 수직 파티셔닝

![image](https://github.com/backend-team-study/cs-study/assets/49775540/5b2c5b7d-0b50-48db-b53d-ca3081d5e7c5)

- 특정 컬럼을 쪼개서 따로 저장하는 형태를 의미한다.
- 하나의 테이블을 2개 이상의 다른 테이블로 분리하는 작업이다. (정규화랑 비슷하나, 수직 파티셔닝은 이미 정규화가 완료된 데이터를 분리하는 것임)
- MySQL 8.0에서는 공식적으로 지원하지 않는다.





## 5.2. 샤딩(Sharding)

### 개념 및 장단점

**개념**

- 샤딩(Sharding)은, 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 기법을 말한다.
- 단순 파티셔닝과의 차이점은, 샤딩은 데이터베이스 자체가 다르게 분산하여 운영한다는 점이다. 즉, 같은 스키마의 테이블을 여러 DB 서버에 저장한다.



**장점**

- 여러 DB 서버를 두기 때문에 처리 속도가 향상되어 응답 시간이 빨라진다.
- 서버 자체를 복제하여 진행하므로 데이터의 고가용성에 용이하다.
- 자원이 작거나 클 때 DB 서버를 붙이거나 떼기만 하면 되므로, 필요시 확장/축소가 용이하다.



**단점**

- 데이터를 여러 DB 서버로 분리해야 하는데, 잘못하면 한쪽 서버로 몰리는 경우가 있을 수 있다. 이를 `핫스팟` 현상이라고 한다.
- 서버 자체를 분산해서 관리하다보니 운영 복잡도가 증가한다.
- 물리적 샤드로 인한 비용이 증가한다.



### 종류

1. **모듈러 샤딩(Modular Sharding)**
   - PK를 DB 개수로 나눈 나머지(모듈러)로 DB를 특정하는 방식을 말한다.
   - 레인지 샤딩에 비해 데이터가 균일하게 분산된다.
   - 하지만 DB를 추가 증설하는 과정에서 이미 적재된 데이터의 정렬이 필요하다.
   - 따라서 이는 데이터 양이 일정 수준 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 어울린다.

2. **레인지 샤딩(Range Sharding)**
   - PK의 범위를 기준으로 DB를 특정하는 방식이다.
   - 모듈러 샤딩에 비해 증설에 재정렬 비용이 들지 않는다.
   - 다만, 일부 DB에 데이터가 몰릴 수 있다.

3. 해시 샤딩(Hash Sharding)
   - PK를 해시 함수를 통과시켜 나온 값으로 DB를 특정하는 방식이다.
   - 해시 값을 기준으로 하기 때문에 랜덤하게 데이터가 고르게 분산된다는 장점이 있다.
   - 랜덤하게 분산되므로, 물리적 샤드를 추가할 때 해시 값을 재할당 하는데 어려움을 겪을 수 있다.



## 5.3. 레플리케이션(Replication)

### 개념 및 장단점

**개념**

- 두 개 이상의 DB를 Master/Slave로 나누어 동일한 데이터를 저장하는 방식을 말한다.
- Master에는 데이터의 수정사항만을 반영하고, 이를 복제하여 Slave에 실제 데이터를 복사한다.



**장점**

- 대부분의 쿼리는 조회 쿼리이므로, Slave를 통해 조회 쿼리를 분산한다면 DB 부하를 많이 낮출 수 있다. (Select 성능 향상)
- Master의 내용을 Slave들이 복제하고 있으므로, 하나가 지워져도 나머지를 활용하면 되므로 백업의 효과도 있다.



**단점**

- Slave는 Master의 복사본을 사용하므로, Slave가 Master와 완전 동일한지 보장할 수 없다. 데이터 정합성에 불일치가 생길 수 있다.
- Master에서 바이너리 로그를 지우더라도 여전히 Slave에는 바이너리 로그가 남아있다.
- Master에서 에러가 발생하는 경우, Slave로 페일오버하는 기능을 지원하지 않는다. -> 클러스터링으로 페일오버를 처리 가능



### 바이너리 로그(Binary Log) 기반 복제

1. Master 노드에 쓰기 트랜잭션이 수행된다.
2. Master 노드는 데이터를 저장하고 트랜잭션에 대한 로그를 파일에 기록한다.(BIN LOG)
3. Slave 노드의 IO Thread는 Master 노드의 로그 파일(BIN LOG)를 파일(Replay Log)에 복사한다.
4. Slave 노드의 SQL Thread는 파일(Replay Log)를 한 줄씩 읽으며 데이터를 저장한다.



## 5.4. 예상 질문

1. 파티셔닝의 개념과 특징을 설명해주세요.
2. 파티셔닝을 사용하면 좋을 사례 하나를 제시해주세요.
3. 파티셔닝의 단점은 무엇이 있을까요?
4. 수평 파티셔닝과 수직 파티셔닝의 개념과 차이점에 대해 간단히 설명해주세요.
5. 수평 파티셔닝의 분할 기준에 대해 한, 두 가지 정도 설명해주세요.
6. 샤딩의 개념과 장점에 대해 설명해주세요.
7. 샤딩의 단점에 대해 설명해주세요.
8. 샤딩의 종류에 대해 아는대로 설명해주세요.
9. DB 레플리케이션의 개념에 대해 설명해주세요.
10. DB 레플리케이션과 샤딩 모두 여러 DB 서버를 둔다는 공통점이 있는데요. 그럼 둘의 차이는 무엇인가요?

