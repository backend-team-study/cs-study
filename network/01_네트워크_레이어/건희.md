# 01 네트워크

# 네트워크 레이어

![image-20231223214358466](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214358466.png)

## OSI 7 계층

### 1 계층 ( 물리 계층 , Physical Layer )

- 실제 장치를 연결하기 위한 **전기적, 물리적 사항을 정의한 계층**
- 데이터를 전기적인 신호로 변환하여 주고받는 계층
- 이 계층에서는 단지 데이터를 전달만 할 뿐 데이터가 무엇인지, 어떤 에러가 있는지에 대해서는 관여 하지 않음
- `ex) 허브, 리피터`

> 리피터 - 단일 포트에 대해 전기 신호를 복원하고 증폭하는 중계 장비
>
> 허브 - 여러 포트에 대해 리피터의 기능을 수행. 브로드 캐스트처럼 모든 대상에게 전달함

### 2 계층 ( 데이터 링크 계층, Data Link Layer ) - Mac 로 통신

- 해당 계층은 장치 간 신호를 전달하는 물리계층을 이용하여 네트워크 상의 주변 장치들 간의 데이터를 전송하는 계층

  - 쉽게 말해 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 수행을 도와주는 역할
  - 따라서 오류도 탐지, 재전송 등의 기능이 있으며, 이 계층에서는 `Mac Address` 를 가지고 통신한다.

  > Mac Address = 네트워크 상에서 서로를 구분하기 위해 장치마다 할당된 물리적 주소 (Lan 카드 주소)

  > 전기 신호로 오류 감지 시 해당 데이터를 폐기함

- **두 지점 간의 신뢰성있는 전송을 보장**하기 위한 계층

- 해당 계층에서 전송되는 단위를 `프레임` 이라고 함.

- `ex) 스위치`

### 3 계층 ( 네트워크 계층, Network Layer ) - IP로 통신

- 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층
- 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 `전송 계층`이 요구하는 서비스 품질을 제공하기 위한 기능적, 절차적 수단을 제공
- 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 주요 역할
- **데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능이 주요함**
- `ex) 라우터, 라우팅 기능을 장착한 Layer 3 스위치`

### 4 계층 ( 전송 계층 Transport Layer ) - Port로 통신

- 이 계층은 통신을 활성화하기 위한 계층이며 보통 TCP 프로토콜을 이용하며, 포트를 열어서 응용프로그램들이 전송을 할 수 있게 한다.
- 만약 데이터가 도착했다면 4 계층에서 해당 데이터를 하나로 통합하여 5 계층으로 전달한다.
- 상위 계층이 데이터 전달의 유효성이나 효율성을 신경 쓰지 않게 해주는 계층
  - 시퀀스 넘버 기반 오류 제어 방식을 사용한다. → SYN
- `ex) TCP, UDP`

### 5 계층 ( 세션 계층 Session Layer )

- 세션 계층은 응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 이를 처리하기 위해 프로세스들의 논리적인 연결을 담당하는 계층이다. 통신 중 연결이 끊어지지 않도록 유지시켜주는 역할 수행하기 위해 TCP/IP 세션 연결의 설정과 해제, 세션 메세지 전송 등의 기능을 수행한다.
  - 세션 계층에서는 이러한 `응용 프로그램 간의 연결 설정 및 해제`, 즉 서비스의 개시와 완료를 담당
  - 데이터 송수신 도중 오류가 발생하면 발생 지점 이후의 데이터만 재전송하도록 한다.
- 통신을 하기 위한 세션 확립, 유지, 중단을 수행한다.
- 통신하는 사용자들을 동기화해주고, 오류 복구 명령들을 일괄적으로 처리한다.
- 프로토콜 : PRC, NetBIOS

### 6 계층 ( 표현 계층 Presentation Layer )

- 애플리케이션이 다루는 정보를 통신에 알맞은 형태로 만들거나, 하위 계층에서 온 데이터를 사용자가 이해할 수 있는 형태로 만드는 역할을 담당하는 계층이다. 데이터의 부호화 및 변환 수행을 통해 송신 장치로부터 온 데이터를 해석한다.
- 데이터의 효율과 보안을 위해 압축과 암호화를 수행하고 ,전송을 위한 포맷으로 변경을 수행한다.

### 7 계층 ( 응용 계층 Application Layer )

- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 계층
- “최종 사용자에 가장 가까운 계층” - 7 계층에서 작동하는 응용프로그램은 사용자와 직접 상호작용한다.

------

## TCP/IP 5계층

## 1. Physical Layer

> 1계층

컴퓨터는 똑똑하면서도 단순하다. 컴퓨터는 `0`과 `1`만 주고받을 수 있으면 모든 파일과 프로그램을 읽고 실행할 수 있다. 단순한 만큼 빠르게 처리할 수 있기 때문에 무수히 많은 0과 1로 이루어진 정보들도 컴퓨터로 뚝딱 계산을 하여 우리 생활에 많은 도움을 주고 있다.

컴퓨터는  `0`과 `1`의 나열을 아날로그 신호로 바꾸어 **전선**으로 흘려보내는 `Encoding` 과정과 흘러 들어온 신호를 해석하는 `Decoding` 과정을 통해 통신을 주고 받는다. 이러한 과정을 가능케 해주는 것이 바로 `Phsical Layer`이다.

Physical Layer는 이름에서 알 수 있듯이 **물리적으로** 연결된 두 대의 컴퓨터가 0과 1의 나열을 주고받을 수 있게 해주는 Module인데, `PHY`칩 이라는 부품으로 `하드웨어적`으로 구현이 되어있다.

## 2. Data - Link Layer

> 2계층

여러 대의 컴퓨터가 통신하려면 어떻게 해야 할까? 위의 1계층에서의 정보를 토대로 생각해보면, 물리적인 전선으로 통신하고 싶은 여러 대의 컴퓨터들을 이어주기만 하면 가능할 것이다. 그런데 만약 수 만대의 컴퓨터가 서로 통신을 하고 싶은 경우라면? 물리적인 전선을 모두 연결해 주는 것으로 해결은 가능하겠지만, 전선을 연결하기 위한 구멍이라던가 전선을 설치하는 비용 등에서도 한계점이 찾아올 것이다.

![image-20231223214426246](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214426246.png)

이에 대한 해결법으로 `Switch` 가 존재한다. Switch는 쉽게 말하면 **중계기, 공유기**이다. 각 컴퓨터들을 이 Switch와 연결을 함으로써 모두가 연결된 것과 같은 효과를 얻을 수 있다. 이렇게 **Swith와 연결된 수 많은 컴퓨터들의 집합**을 우리는 **네트워크**라고 부른다.

이번엔 이와 같이 수 많은 컴퓨터가 연결된 상황에서 생각해볼 수 있는 한 가지 상황을 이야기해보자.  `A, B, C` 라는 컴퓨터가 각각 `0101, 1110, 0001` 이라는 데이터를 `D` 컴퓨터에게  거의 동시에 보낸다면 D 컴퓨터는 `010111100001` 과 같은 형태로 데이터를 받게된다. 이러한 데이터를 어디서 끊어 읽는지에 따라 옳바른 데이터 처리가 결정될 것이다. 이를 위해 송신자는 데이터의 앞 뒤에 특정한 bit열을 붙인다.

예를 들자면 **시작을 의미**하는 1111과 **끝을 의미**하는 0000을 붙여 1111 0101 0000과 같은 형태로 데이터를 보내는 것이다. 이러한 작업을 `Framing`이라고 한다.

정리하자면, Data - Link Layer란 같은 네트워크에 있는 여러 대의 컴퓨터들이 데이터를 주고받기 위해서 필요한 모듈인 것이다. 2계층 모듈 역시 1계층 모듈과 마찬가지로 LAN 카드라는 부품으로 하드웨어적으로 구현이 되어 있다.

## 3. Network Layer

> 3계층

좀 더 나아가서 자신의 네트워크에 속하지 않은 컴퓨터에게 정보를 전달하려고 할 때는 어떻게 하면 좋을까? 이때에는 Switch와 Switch를 연결하여 서로 다른 네트워크에 속한 컴퓨터끼리 통신을 가능케 하는 `Router`를 사용하면 된다. Router의 상위 계층으로 올라가면 국가와 국가 간의 통신을 연결해야 하는 지점이 존재하는데, 우리는 이러한 지점에 해저 케이블을 설치하여 글로벌 네트워크를 구축하고 있으며, 이러한 식으로 전 세계의 컴퓨터들이 계층구조로 연결되어 있는 것을 **인터넷**이라고 한다.

위에서 들었던 예시를 다시 적용하여 자신이 속한 네트워크가 아닌 다른 네트워크의 컴퓨터에게 데이터를 보내기 위해서는 상대방의 IP 주소를 알아야 한다. IP 주소를 어떻게 알 수 있냐하면 사실 우리는 이미 IP 주소를 알고 있다.  [www.naver.com](http://www.naver.com) 을 입력하면 DNS를 통해 IP 주소로 변환되어 해당 IP에 접속하는 것처럼 이미 우리는 상대방의 IP 주소를 알고 있다.

위에서는 아까 Framing이라는 작업을 통해 데이터의 시작과 끝을 알렸던 것처럼, 이곳에서는 데이터의 앞에 IP 주소를 붙여 `Packet`이라는 데이터를 만들어 전송한다.

라우터는 전달받은 패킷을 열어 IP 주소를 확인하고 자신이 전달할 수 있으면 전달하고, 그렇지 못한다면 다른 라우터로 다시 보내주어 목적지까지 배달한다.

이렇듯 수많은 네트워크들의 집합 Inter Network 속에서 IP 주소를 이용해 길을 찾는 것을 `Routing`, 이것을 다음 라우터에게 넘겨주는 것을 `Forwarding`이라 한다.

> **😁 네트워크 데이터 단위**
>
> - Socket에서 다루는 데이터 단위는 
>
>   Stream
>
>   - Stream : 시작은 알지만 끝은 모름
>   - Socket을 Network단으로 보내면 Stream 데이터가 Segment화 된다 (데이터를 자름) = Segmentaion
>
> - TCP에서 다루는 데이터 단위 
>
>   Segment
>
>   - Socket에서 받은 잘린 Stream 데이터
>   - MSS (Maximum Segment Size) 일정 길이의 최대값. MSS는 MTU보다 당연히 작다
>
> - IP에서 다루는 데이터 단위 
>
>   Packet
>
>   - Segment를 인터넷 환경에서 전송 가능한 상태로 포장한 형태
>   - MTU (Maximum Trasnport Unit) 특별한 이유가 없다면 1500bytes
>
> - H/W단에서 다루는 데이터 단위 
>
>   Frame
>
>   - Packet을 실어 나를 때는 다시 Frame 데이터에 넣는다

3계층은 운영체제의 Kernel에 소프트웨어적으로 구현되어있다.

> 😎 **Kernel** 이란?
>
> 커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 **자원들을 관리하는 역할을 한다**.
>
> 즉, 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 여러가지 하드웨어 (CPU, Memory) 등의 리소스를 관리하는 역할을 한다.
>
> https://minkwon4.tistory.com/295

## 4. Transport Layer

> 4계층

위의 3가지 계층들을 통해 우리는 세계적인 범위로 데이터를 주고받을 수 있게 되었다. 그렇다면 이제 전송받은 혹은 전송한 데이터를 어떠한 프로세스에게 어떻게 전달해주면 좋을까? 우리는 `Port`를 통해 이를 전달하고 있다. 실행중인 프로그램(`프로세스`)들은 모두 고유한 정수의 Port 번호를 지니고 있다. `MySQL`을 사용해봤다면 `3306`이라는Port 번호가 익숙할 것이다. 또 웹 개발을 진행했다면 `8080`이라는 `Port` 번호 역시 익숙할 것이다.

이처럼 우리는 Port 번호를 이용하여 어떤 프로세스에 어떤 데이터를 넘길 것인지 결정할 수 있게 된다. 따라서 데이터 송신자는 데이터를 보낼 때 데이터를 받을 수신자 컴퓨터에 있는 프로세스의 Port 번호를 붙여서 보내야 한다.

> 우리가 검색창에 [www.naver.com](http://www.naver.com) 을 입력하는 것은 사실 [www.naver.com:80](http://www.naver.com:80) 이라는 포트 번호를 생략한 형태이다. 즉, 우리는 우리도 모르게 naver의 Port 번호를 알고 데이터를 주고받고 있던 것이다

즉, Transport Layer란 Port 번호를 사용하여 도착지 컴퓨터의 최종 도착지인 프로세스에 까지 데이터가 도달하게 하는 모듈인 것이다. 이 역시 3계층과 마찬가지로 운영체제의 커널에 소프트웨어적으로 구현되어 있다.

## 5. Application Layer

> 5계층

사용자와 가장 가까운계층으로 **사용자 - 소프트웨어 간 소통을 담당하는 계층**이다.

애플리케이션을 실행하기 위한 데이터 형식이 작성된다.

> TCP/IP 소켓 프로그래밍
>
> - 운영체제의 Transport Layer 에서 제공하는 **API를 활용해서 통신 가능한 프로그램**을 만드는 것. 다른 말로 소켓 프로그래밍, 네트워크 프로그래밍이라고 함
> - 소켓 프로그래밍만으로도 클라이언트, 서버 프로그램을 따로따로 만들어서 동작 시킬 수 있다
> - TCP/IP 소켓 프로그래밍을 통해서 누구나 자신만의 Application Layer 인코더와 디코더를 만들 수 있다. → 자신만의 프로토콜을 만들어서 사용할 수 있다

대표적인 프로토콜로 HTTP, HTTPS, FTP, SSH, DNS, SMTP 등이 있다.

------

## IPv4 vs IPv6

- Internet Protocal Versin 4, 6
- ipv4 는 **32bit(2진수로 표현)**, ipv6는 **128bit (16진수로 표현)**
- ipv6는 ipv4 주소 고갈을 극복하기 위해 탄생
- ipv4는 유니, 멀티, 브로드 캐스트 가능
- ipv6는 유니, 멀티, 애니 캐스트 가능

### IPv6 도입 문제

1. 호환성 문제

2. 전환 비용 및 리소스

3. 보안 고려 사항

   새로운 보안 도전 과제를 동반

4. IPv4를 같이 관리해야 하므로 복잡함

------

## 캐스트 종류

### 유니 캐스트

- 출발지와 목적지가 정확해야 하는 일대일 통신
- 어떤 시스템이 유니캐스트 방식으로 데이터를 전송하게 되면 같은 네트워크에 있는 모든 시스템들은 그 MAC 주소를 받아서 자신의 MAC 주소와 비교 후에 자신의 MAC 주소와 같지 않다면 프레임을 버리고 같다면 프레임을 받아서 처리하게 된다.
  - 대상이 아니면 프레임을 드랍하기 때문에 CPU 성능에 문제를 주지 않음

### 브로드 캐스트

- 같은 네트워크에 있는 모든 장비들에게 보내는 통신

- 브로드캐스트용 주소가 미리 정해져있고, 수신 받는 시스템은 패킷을 자신의 CPU로 전송하고 필요한 정보인지 판별함 → CPU 사용

- 교내 안내 방송과 같이 **수신자가 거부할 수 없음**

  - 나에게 필요한 정보인지 확인하는 과정에서 **CPU를 사용하게 됨**
  - 때문에 과도한 브로드캐스트는 네트워크 및 **PC 성능을 저하**
  - 주로 상대 IP는 알지만 MAC을 모를경우 사용 → ARP 시도의 경우

  > ARP → Address Resolution Protocol → 주소 결정 프로토콜
  >
  > IP와 MAC 주소를 일대일 대응시켜 ARP 테이블로 관리
  >
  > 목적지의 물리주소를 알아내기 위해 브로드 캐스트 방식으로 전송함

### 멀티 캐스트

- 여러명에게 보내야 할 경우에 사용하는 방식으로 유니 + 브로드를 합쳐놓은 듯한 개념
- 특정 그룹을 지정해서 해당 그룹원에게만 보내는 방식
- 패킷에 수신자의 주소 대신 수신자들이 참여하고 있는 그룹 주소를 표시
- 스위치나 라우터가 멀티 캐스트 방식을 지원해야 사용 가능

### 애니 캐스트

- 가장 가까운 Node와 통신하는 방식
- 유니캐스트와 다른 점은 **네트워크에 연결된 수신 가능한 노드 중**에서 한 노드에만 데이터를 전송
- 유니 캐스트에서는 후보군이 하나지만, 애니 캐스트에서는 같은 목적지 주소를 가진 서버가 여러대여서 통신 가능한 다수의 후보군이 있다.
- 즉, 요청을 효율적으로 처리할 수 있는 가장 가까운 곳으로 트래픽을 라우팅 함
  - 선택적 라우팅을 통해 트래픽 분산, DDoS 공격에 탄력적 대처 가능
- `DNS` 서비스에 많이 활용됨
- 라우터에서는 라우터 이기 때문에 L4/L7 와 달리 서버의 어플리케이션의 헬스체크가 안되어서 이상동작 여부를 판단 할수 없습니다.

------

## Subnet

- IPv4로 구성된 인프라를 최대한 활용하기 위해서 IPv4 체계의 IP 주소를 사용하는 네트워크의 `규모에 따라 관리하기 쉽도록` 클래스라는 이름으로 나누기 시작하여 네트워크 클래스가 등장함.

![image-20231223214448497](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214448497.png)

클래스 단위로 네트워크를 분류하다보니, 어떤 기업에서는 적은 양의 호스트 주소가 필요한데, B Class 네트워크를 할당받아서 IP 주소에 여유가 생기게 되고, 어떤 기업에서는 부족해지는 현상이 생기게 된다.

**따라서 클래스로만 네트워크를 분류하는 것은 비효율적이라는 결론이 나오고, 좀 더 적절한 단위로 네트워크를 분할해야할 필요성이 대두된다. + 네트워크의 규모를 줄여서 브로드 캐스팅의 빈도를 줄여 부하 절감함**

이에 등장한 것이 서브넷이다. 서브넷이라는 것은 **하나의 네트워크가 분할되어 나눠진 작은 네트워크**이다. 네트워크를 분할하는 것을 `서브네팅`이라고 한다. 이 서브네팅은 `서브넷 마스크`를 통하여 수행될 수 있다.

------

## CIDR (Classless Inter-Domain Routing)

- 클래스 없는 도메인간 라우팅 기법
- `192.168.10.0/24` 라는 IP 주소가 존재할 때 맨 뒤의 ‘24’가 사이더 표기법이다.
- 서브네팅과 슈퍼네팅 모두 CIDR의 일환이다

------

## TCP

IP (Internet Protocol) 가 인터넷 망 속에서 클라이언트와 서버 간에 통신이 가능하게끔 IP 주소와 패킷을 통해 통신을 한다면, TCP (Transmission Control Protocol) 는 IP 규칙으로만 통신하기에 부족하거나 불안정하던 여러 단점들 (패킷 순서가 이상해지거나 유실) 을 **커버해, 패킷 전송을 제어하여 신뢰성을 보증하는 프로토콜**이다.

- IP 규칙대로 목적지에 도달했다면, TCP 규칙대로 올바르게 도착했는지 정확히 누구에게 전달되어야하는지 일일이 따진다고 생각하면 된다. 그래서 은행 업무나 메일과 같은 반드시 수신자가 정보를 받아야하는 신뢰성 있는 통신에 사용된다.

![image-20231223214500158](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214500158.png)

TCP는 신뢰성 프로토콜답게, 배달하기 전에 목적지가 무사한지 미리 확인하고 배달 끝나고도 또 확인하는 프로토콜이다. 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 물어보고 패킷을 전송할 순서를 정한 뒤에야 본격적인 통신을 시작한다.

이러한 과정이 3 Way Handshake와 4 Way Handshake 과정이다.

둘다 똑같은 핸드쉐이크지만, 3 Way는 통신을 시작할 때, 4 Way는 통신을 마칠때 거치는 과정이라는 차이만 있을뿐이다. 한 마디로 한 번 통신하는데 핸드쉐이크를 두 번 하기 때문에 신뢰성을 보장한다.

![image-20231223214511082](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214511082.png)

위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 SYN와 ACK라는 패킷을 주고 받고, 통신을 종료하는 과정에선 FIN 이라는 패킷을 주고 받는 것을 확인할 수 있다.

### 3 Way Handshake 과정

1. 클라이언트는 접속을 요청하는 SYN을 보낸다. 이때 클라이언트는 응답을 기다리기위해 SYN_SENT 상태로 변한다.
2. LISTEN 상태였던 서버는 SYN 요청을 받으면, 클라이언트에게 요청을 수락하는 ACK와 SYN 패킷을 보낸다.
3. 클라이언트는 다시 서버에 ACK를 보내고, 이 후 ESTABLISHED 상태가 되어 데이터 통신이 가능하게 된다.

### 데이터 통신 과정

1. ESTABLISHED 상태에서 데이터를 보낸다.
2. 수신측은 잘 전송받았다고 ACK를 넣어 응답한다.
   1. **데이터를 쪼개서 받기 때문에 다음 받을 데이터 번호도 같이 보낸다고 한다. (Stop and Wait 방식)**
   2. 서버는 이 ACK를 기다리기 때문에 WAIT 상태로 들어가게 되는데 이 과정에서 속도 지연이 발생한다.
   3. 단순히 송신측만 생각해볼 것이 아니라 수신측에서 데이터를 읽는 속도도 생각해보아야 한다.
3. 만약 ACK가 오지 않는다면 전송측은 데이터를 재전송한다.

### 4 Way Handshake 과정

1. 클라이언트가 접속을 끊기 위해 close() 함수를 호출한다. 그러면 FIN 플래그를 보내게 되고 클라이언트는 `FIN_WAIT 1`상태로 변한다.
2. 서버는 CLOSE_WAIT 상태로 바꾼 후 ACK 플래그를 전송한다. 만일 서버에서 클라이언트로 보낼 남은 데이터가 있을 경우 이때 나머지를 모두 전송시킨다.
3. ACK를 받은 클라이언트는 FIN_WAIT 2로 변환되고, 이때 서버는 CLOSE() 함수를 호출하여 FIN 플래그를 클라이언트에게 보낸다.
4. 클라이언트가 FIN을 수신하면 ACK를 서버로 보낸 후 서버가 ACK를 확인하고 연결을 종료한다.

### TCP의 전송 제어 기법

단어 그대로 **원활한 통신을 위해 전송 흐름을 제어하는 기능**을 프로토콜 자체에 포함하고 있다. TCP가 없었더라면 개발자가 일일이 데이터를 어떤 단위로 보낼 것인지 정의해야하고, 유실 시에는 어떻게 대처할 것인지도 생각해야 한다. `**TCP 고마워요~**`

### 1. 흐름 제어 (Flow Control)

![image-20231223214521961](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214521961.png)

- 수신자가 처리할 수 있는 데이터 속도가 다르기 때문에, 송신 측은 수신 측의 데이터 처리 속도를 파악하고 얼마나 빠르게 어느 정도의 데이터를 전송할 지 제어
- 슬라이딩 윈도우 방식을 사용

### 2. 오류 제어 (Error Control)

- ![image-20231223214532744](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214532744.png)통신 도중에 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처
- Go Bank N 기법과 Selective Repeat 기법을 사용
  - Go Bank N : 어느 데이터로부터 오류가 발생하였는지 파악하여, 그 부분만 다시 순서대로 보내는 방법
  - Selective Repeat : 오류가 발생한 데이터만 재전송하고, 그 전에 받았던 순서가 잘못된 버퍼를 재정렬하는 방법

### 3. 혼잡 제어 (Congestion Control)

- 네트워크가 불안정하여 데이터가 원활히 통신이 안되면 제어를 통해 재전송을 하게 되는데, 재전송 작업이 반복되면 계속해서 데이터가 쌓이기 때문에 네트워크가 붕괴될 수도 있다. 따라서 네트워크 혼잡 상태가 감지되면 송신 측의 전송 데이터 크기를 조절하여 전송량을 제어한다.

------

## UDP (User Datagram Protocol)

인터넷 기술이 발전하면서 전송해야하는 데이터도 단순 텍스트를 넘어 동영상이나 음악과 같은 멀티미디어도 전송하면서 데이터의 크기가 저점 커져가며 동시에 빠른 통신이 필요해 졌다. 그래서 HTTP 2.0 에서는 한 번 연결된 TCP 회선을 길게 유지하고 데이터도 스트림이라는 특수한 형태로 보내는 식으로 극복을 했지만, TCP 자체가 가지는 근본적인 특징때문에 결과적으로 속도 한계가 있었다. (쉐이킹 과정이 계속 필요하기 때문에)

하지만 UDP의 데이터그램 방식은 패킷의 목적지만 정해져있다면 중간 경로는 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요하지 않다. 즉, UDP의 속도가 더 빠를 수 밖에 없다. UDP는 이러한 핸드 쉐이킹 과정을 구현하지 못한 게 아니라 탑재하지 않은 것인데, 때문에 UDP를 커스터마이징이 가능하여 TCP와 비슷한 수준의 기능을 가지게도 할 수 있다.

![image-20231223214545301](C:\Users\WEON\AppData\Roaming\Typora\typora-user-images\image-20231223214545301.png)