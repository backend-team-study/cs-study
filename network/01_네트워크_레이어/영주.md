# 01. 네트워크 레이어

> 김영주

<br>

## 1.1. OSI 7계층

> Open System Interconnection Reference Model

![image](https://github.com/backend-team-study/cs-study/assets/49775540/88e3101a-00d5-491b-b754-dce9de2453bb)

- `OSI 7계층`이란, 국제 표준화기구 ISO에서 1984년에 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것을 말한다.

- 서로 다른 장비 간의 통신을 위해 만든 표준 규칙이며, 계층별로 독립적으로 모듈화하여 특정한 곳에 이상이 생겼을 때 다른 곳을 건드리지 않고도 해당 부분만 고칠 수 있게 고안되었다.
- 본질은 ``데이터``를 전달한다는 것이다. 하지만 데이터를 누구에게 어떻게 보낼지에 대한 정보가 필요하므로 각 계층을 거치며 추가적인 정보를 덧붙인다.
  - `캡슐화` : 송신자가 보내는 데이터가 상위 계층부터 하위 계층을 거치며 포장되는 것
  - `역캡슐화` : 수신할 때 하위 계층부터 상위 계층을 거치며 분해하여 데이터를 추출하는 것

<br>

### 1) 물리 계층 (Physical layer)

> 데이터를 전기신호로 바꾸어 전송하는 역할
> 주요 용어 : 비트, 케이블, 허브

컴퓨터끼리는 `비트(bit)`라고 불리는 0과 1로만 통신할 수 있다. 이를 주고받기 위해서는 0과 1의 비트를 전기 신호로 변환해야 한다.

여기서 전기 신호란, 아날로그 신호와 디지털 신호를 말한다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/822f95cf-4b1f-468a-8fc2-bc908fecbd4f)

- `아날로그 신호` : 0에서 1사이의 연속적인 값을 갖는 신호
- `디지털 신호` : 0 혹은 1의 정확한 값을 갖는 신호

컴퓨터는 0과 1을 사용하므로 디지털 신호를 이용해 전기를 흐르게 하거나(1), 흐르지 않게 하면(0) 된다.

하지만 **디지털 신호는 무한대의 대역폭을 가지기 때문에, 실제로 전송을 할 때는 케이블에서 지원하지 않는 대역폭에 해당하는 몇몇 신호가 전송되지 않는다.**

<br>

따라서 물리 계층에서는 이런 디지털 신호를 아날로그 신호로 변환하여 데이터를 전송한다. 그리고 이를 담당하는 하드웨어가 `랜카드`이다.

랜카드는 송신 측에서는 0과 1의 데이터를 전기 신호로 변환하고, 수신 측에서는 전기 신호를 다시 0과 1의 데이터로 변환하는 작업을 수행한다.

변환된 전기 신호는 트위스트 페어 케이블을 통해 전달되는데, 보통 UTP와 STP 케이블로 나뉜다.

<br>

**트위스트 페어 케이블(Twisted Pair Cable)**

![image](https://github.com/backend-team-study/cs-study/assets/49775540/35085d19-df18-4ce6-8dd8-26877f58f6c7)

- `UTP 케이블` : 구리 선 여덟 개를 두 개씩 꼬아 만든 네 쌍의 전선으로 실드로 보호되어 있지 않는 케이블
- `STP 케이블` : 구리 선 여덟 개를 두 개씩 꼬아 만든 네 쌍의 전선을 실드로 보호한 케이블

여기서 `실드`는 금속 호일이나 금속의 매듭과 같은 것으로 외부의 노이즈를 막는 역할을 한다. 따라서 STP 케이블이 전송 품질이 더 좋다. 

하지만 비용 문제로 인해 주로 UTP 케이블을 많이 사용한다.

<br>

트위스트 페어 케이블은 **랜 케이블(LAN cable)**이라고도 하는데, 구리 선 연결 순서에 따라 다이렉트 케이블과 크로스 케이블로 나눌 수 있다.

참고로 케이블은 총 8개의 구리선이 있는데, 실제로는 1, 2, 3, 6번의 구리 선만 송수신을 위해 이용되는 편이다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/1c106547-cf5c-4db1-b8a7-2db63bcf8783)

- `다이렉트 케이블` : 한 쪽의 송신을 담당하는 구리선(1, 2번)과 다른 쪽의 수신을 담당하는 구리선(1, 2번)이 연결된 케이블로, 송수신 연결이 같은 번호의 구리선을 이용한다.
- `크로스 케이블` : 한 쪽의 송신을 담당하는 구리선(1, 2번)과 다른 쪽의 수신을 담당하는 구리선(3, 6번)이 연결된 케이블로, 송수신 연결이 다른 번호의 구리선을 이용한다.

<br>

현재까지, 보내고자 하는 데이터를 랜카드를 통해 전기 신호로 바꾸고 랜 케이블로 다른 컴퓨터에 전송하는 것에 대해 알아보았다.

이는 두 대의 컴퓨터가 직접적으로 통신할 때 필요한 최소 조건인데, 그렇다면 **컴퓨터 여러 대가 통신하려면 어떻게 해야할까?**

<br>

일단 아래와 같이 모든 컴퓨터를 서로 케이블로 연결하는 방식이 있을 수 있다. 이른바 완전 그래프의 형태로 연결하는 것이다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/772a663d-d213-404b-88d6-7d9ef456d4de)

N개의 정점(컴퓨터)이 있는 완전 그래프의 특성 상, 간선(케이블)의 개수가 `N(N-1)/2` 개 만큼 필요하므로 매우 비효율적이다.

따라서 아래와 같이 공통적으로 `허브`를 연결하면 케이블이 낭비되는 문제를 해결할 수 있다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/d18bec49-c0f2-4b1e-83bb-de171ff31541)

`허브(Hub)`는 전기 신호를 정형하고 증폭하는 기능과 함께, 여러 컴퓨터를 연결하는 기능을 수행한다.

단, 하나의 컴퓨터에서 데이터를 보낼 때 특정 컴퓨터에만 해당 데이터를 보낼 수 없고 연결된 모든 컴퓨터에 데이터가 전송된다는 특징이 있다.

그래서 `더미 허브(Dummy Hub)`라고 불리기도 한다. 이는 효율면에서도 보안면에서도 문제가 있을 수 있다.

따라서 **데이터 링크 계층**에서는 특정 컴퓨터에게만 데이터가 전달 될 수 있도록 **목적지**를 추가하여 이런 문제를 해결하고자 한다.

<br>

### 2) 데이터 링크 계층 (Data link layer)

> 네트워크 장비 간에 신호를 주고받는 규칙
> 주요 용어 : 이더넷, 프레임, 스위치

물리 계층은 단순히 데이터를 전기 신호로 변환하고, 케이블을 통해 전송하는 역할만 수행한다.

하지만 어떤 컴퓨터에게 데이터를 전달할지, 해당 데이터가 잘 전달되었는지에 대해서는 알 수 없다. 이를 데이터 링크 계층에서 보완할 수 있다.

<br>

데이터 링크 계층에서는 일반적으로 **이더넷(Ethernet)**이라는 규칙을 통해 데이터를 주고 받는다.

- 이더넷은 48비트의 고유 `MAC 주소`를 통해 목적지를 정의한다.
- 이더넷은 트래픽을 조절하고 안정성을 유지하기 위해 `CSMA/CD(반송파 감지 다중 접속/충돌 탐지)` 프로토콜을 사용한다.

<br>

**MAC 주소(Media Access Control Address)**란, 랜카드에 할당된 고유 식별 주소를 말한다.`1A-F2-3A-05-7D-FF` 형식의 `48비트 `숫자이다.

이는 네트워크 연결이 가능한 모든 장비에 식별자로써 존재하며, MAC 주소를 통해 어느 장비로 데이터를 보낼지 명시할 수 있게 되었다.

- `앞의 32 비트`는 랜카드를 만든 제조사 번호를 의미한다.
- `뒤의 32 비트`는 랜카드를 만든 제조사가 붙인 고유 일련번호를 의미한다.

<br>

데이터 링크 계층에서는 네트워크 계층에서 내려온 패킷의 앞뒤에 각각 `이더넷 헤더와 트레일러`를 붙여 추가적인 정보를 표시한다.

이를 **프레임(Frame)**이라고 하며, 데이터 링크 계층의 기본 전송 단위가 된다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/dcf37edd-26ec-411c-bb2e-7a6728d449cc)

- `이더넷 헤더` : 출발지 MAC 주소, 도착지 MAC 주소, 이더넷 타입으로 이루어져있다.
  - `이더넷 타입`은 이더넷으로 전송되는 상위 계층 프로토콜의 종류를 나타내며, 다음과 같은 종류가 있다. (16진수)
    - 0800 : IPv4
    - 0806 : ARP
    - 8035 : RARP
    - 814C : SNMP over Ethernet
    - 86DD : IPv6

- `이더넷 트레일러` : `FCS(Frame Check Sequence)`를 통해 프레임에 문제가 있는지 판별한다. 
  - `순환중복검사(Cyclic Redundancy Check, CRC)`를 통해, 송신측에서 데이터로부터 다항식에 의해 추출된 결과를 여분의 FCS에 덧붙여 보내면, 수신측에서 동일한 방법으로 추출한 결과와 일치하는지 판단하여 오류를 검사한다.

<br>

허브는 한 컴퓨터가 보낸 데이터를 포트에 연결된 모든 컴퓨터들에게 전달한다. 각 컴퓨터들은 프레임에 있는 도착지 MAC 주소가 자신의 MAC 주소와 일치하는지 판별하고, 일치하지 않으면 받은 데이터를 파기한다. 일치하면 해당 컴퓨터는 정상적으로 데이터를 수신한다.

<br>

이더넷은 또한 **CSMA/CD 프로토콜**을 이용해, 데이터의 충돌을 방지한다.

여러 컴퓨터가 허브를 통해 연결되어 있기 때문에, 만약 컴퓨터 여러 대가 한꺼번에 데이터를 송신하면 데이터끼리 충돌이 일어날 수 있다.

CSMA/CD는 다음과 같은 의미를 가진다.

- 먼저, 데이터를 보내려고 하는 컴퓨터가 케이블에 신호가 흐르고 있는지 아닌지를 확인한다. -> `CS (Carrier Sense)`
  - Carrier란 네트워크 상에 나타나는 신호를 의미한다. 따라서 Carrier Sense란 네트워크 상의 통신 즉, 캐리어가 있는지를 감지하는 것을 의미한다.
- 케이블에 데이터가 흐르고 있지 않다면 데이터를 전송한다. -> `MA (Multiple Access)`
- 충돌이 발생하고 있는지 확인한다. -> `CD (Collision Detection)`

<br>

요즘은 스위치의 등장으로 더이상 CSMA/CD는 잘 사용되지 않는다.

`스위치`는 L2 스위치 혹은 스위칭 허브라고도 불리며, 허브와 역할이 비슷하지만 데이터 충돌이 발생하지 않는 구조를 가진다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/42feb189-cabc-44ae-9bc1-db8446343517)

스위치는 자신의 포트 번호와 해당 포트에 연결된 컴퓨터들의 MAC 주소를 데이터베이스 형태로 가지고 있다. (`MAC 주소 테이블`)

최초 스위치를 켤 때는 MAC 주소 테이블이 비어있으나, 도착지에 방문하는 순간 MAC 주소를 테이블에 등록한다. (`MAC 주소 학습 기능`)

스위치는 프레임의 도착지 MAC 주소가 테이블에 등록되지 않은 상태에서 데이터를 보내면, 연결된 모든 컴퓨터에 정보를 보낸다. (`플러딩 현상`)

만약 도착지 MAC 주소가 테이블에 등록되어 있다면, 해당 도착지로 프레임을 전송한다. (`MAC 주소 필터링`)

허브와 달리 스위치는 **전이중 통신 방식**을 사용하기 때문에, 여러 컴퓨터가 데이터를 동시에 전송해도 충돌이 발생하지 않는다. 그래서 요즘은 허브 대신 스위치를 사용하는 것이 표준이 되었다.

<br>

데이터 링크 계층을 통해 같은 네트워크 상에서 원하는 도착지 컴퓨터로 데이터를 보낼 수 있게 되었다.

하지만 실제 세상은 수많은 장비와 네트워크가 존재하는데, 다른 네트워크에 있는 컴퓨터와는 어떻게 통신할 수 있을까?

이 문제를 네트워크 계층을 통해 해결하고자 한다.

<br>

### 3) 네트워크 계층 (Network layer)

> 서로 다른 네트워크에 있는 노드에 데이터를 전송하는 역할
> 주요 용어 : IP, 패킷, 라우터

데이터 링크 계층에서 MAC 주소를 이용해 특정 컴퓨터에 데이터를 전송할 수 있었다. 하지만 이는 어디까지나 **같은 네트워크(같은 스위치에 연결된 컴퓨터들의 집합)**에 한정된다.

다른 스위치에 있는 컴퓨터에 데이터를 보내려면 `라우터`라는 장비가 필요하다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/897f3734-ee7d-4d18-8129-17c209c27254)

라우터는 데이터의 목적지가 정해지면, 해당 목적지까지 어떤 경로로 가는 것이 좋은지 알려주는 역할을 한다.

스위치에 MAC 주소 테이블이 있듯, 라우터에는 **라우팅 테이블**을 통해 경로 정보를 등록하고 관리한다.

<br>

다른 장비에 데이터를 보내기 위해 MAC 주소가 필요하듯, 다른 네트워크에 있는 장비에 데이터를 보내기 위해 **IP 주소**라는 것이 필요하다.

IP 주소란, 네트워크 상에서 컴퓨터가 가지는 고유한 주소를 말하며, 전송 계층에서 내려온 세그먼트에 IP 헤더를 붙여 캡슐화한다.

이를 **패킷(Packet)**이라 하며, 네트워크 계층의 기본 전송 단위가 된다. (하나의 패킷은 최대 65536 바이트의 크기)

![image](https://github.com/backend-team-study/cs-study/assets/49775540/f9c5ba69-92bf-4ce9-bef1-154675be41b3)

여러 정보가 있지만 가장 중요한 것은 `출발지 IP 주소`와 `도착지 IP 주소`가 명시되어 있다는 점이다. 이를 통해 다른 네트워크의 도착지를 찾아간다.

<br>

위의 IP 헤더는 일반적으로 많이 사용하는 IPv4의 헤더 구조이다.

IPv4는 `2^32개(약 43억개)`가 배정될 수 있는데, 이는 IoT 시대가 도래하며 부족해지는 현상이 나타났다.

이런 주소 고갈 문제를 해결하고자 IPv6가 등장하였으나, 그 전에 주소 고갈 문제를 다른 방법으로 어떻게 해결하고자 했는지를 먼저 살펴보자.

<br>

일단, 모든 장비에 고유한 IP 주소를 할당할 수 없기 때문에, IP 주소를 공인 IP와 사설 IP로 나누어 관리하기 시작했다.

- `공인 IP` : 인터넷 서비스 제공자(ISP)를 통해 부여받은 **고유한 IP 주소**이다. 인터넷에 직접 맞닿아있는 컴퓨터나 라우터에 할당한다.
- `사설 IP` : 특정 네트워크 안에서 **내부적으로 사용되는 IP 주소**이다. 공유기에 연결된 가정이나 회사의 각 컴퓨터에 할당한다. (= 로컬 IP)

공인 IP는 전 세계에서 유일하나, 사설 IP는 하나의 네트워크 안에서만 유일하다. 따라서 사설 IP는 중복될 수 있어, 주소 고갈을 조금이나마 해소했다.

<br>

사설 IP는 라우터의 **DHCP(Dynamic Host Configuration Protocol)** 기능을 이용하여 자동으로 할당된다.

1. 공유기에 내 컴퓨터를 연결하면 자동으로 DHCP 클라이언트(내 컴퓨터)의 MAC 주소가 DHCP 서버에게 IP 주소를 요청한다.
2. DHCP 서버는 DHCP 클라이언트에게 사용 가능한 IP를 자동으로 할당한다.
3. 할당 받은 IP 주소는 영구적이지 않으므로, 기간이 만료되면 연장하거나 주소를 반납해야한다.

<br>

사설 IP는 특정 네트워크 내에서만 유일하므로, 외부와 통신하기 위해서는 **NAT(Network Address Translation)**의 도움이 필요하다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/475840f6-28bb-4222-a9aa-312077d609f5)

1. 내 컴퓨터로 특정 사이트에 접속을 하고 싶다면, 먼저 게이트웨이에 해당하는 공유기에 신호를 보낸다. (보통 공유기가 게이트웨이 역할을 수행)
2. 게이트웨이는 요청받은 내 컴퓨터의 내부 IP 주소를 기록한다.
3. **내 컴퓨터의 내부 IP 주소는 사설 IP이므로 게이트웨이는 이를 자신이 가진 공인 IP로 변환한다. (`NAT의 역할`)**
4. 게이트웨이는 공인 IP로 해당 사이트에 접속 요청을 하고 응답을 받는다.
5. 받은 응답 내용을 이전에 기록해놨던 내 컴퓨터의 내부 IP 주소로 보낸다.

<br>

또한, IPv4의 주소 고갈 문제를 해결하기 위해 **IP 주소를 클래스 별로 구분**하였다.

IPv4는 크게 두 가지 부분으로 나눌 수 있다.

- `네트워크 ID` : 어떤 네트워크인지를 나타내는 부분
- `호스트 ID` : 해당 네트워크의 어떤 컴퓨터인지를 나타내는 부분

IP 주소를 클래스 별로 구분한다는 것은, IP 주소를 구성하는 네트워크 ID와 호스트 ID의 크기를 조정하여 여러 분류로 구분한다는 의미를 가진다.

- `A 클래스` : 8비트의 네트워크 ID, 24비트의 호스트 ID (대규모 네트워크)
- `B 클래스` : 16비트의 네트워크 ID, 16비트의 호스트 ID (중규모 네트워크)
- `C 클래스` : 24비트의 네트워크 ID, 8비트의 호스트 ID (소규모 네트워크, 가정에서 주로 사용하는 사설 IP 주소들이 여기에 포함됨)

D, E 클래스도 존재하는데 총정리 하면 아래와 같다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/41b4fdc5-aa74-4d17-98eb-f52a401ad927)

<br>

참고로 **특정 컴퓨터에 할당할 수 없는 IP 주소**도 존재한다.

- `네트워크 주소` : 호스트 ID가 0에 해당하는 IP 주소 (ex. 192.168.1.0)
  - 네트워크 주소는 특정 네트워크 전체를 대표하는 주소가 된다. 보통 전체 네트워크에서 작은 네트워크를 식별하기 위한 주소로 사용된다.
- `브로드캐스트 주소` : 호스트 ID가 255에 해당하는 IP 주소 (ex. 192.168.1.255)
  - 브로드캐스트 주소는 특정 네트워크에 있는 모든 장비에게 한 번에 데이터를 전송하기 위해 사용된다.

이 두 주소는 보통 특정 IP 주소 범위의 시작과 끝에 해당하며, 특정 장비에 할당될 수 없다.

<br>

이전에 말했듯이 클래스로 구분하여 IPv4의 주소 고갈 문제를 해결하려고 했으나, 오히려 이 방식이 비효율적인 것이 되어버렸다.

예를 들어, 특정 기업에 B 클래스 그룹 하나를 할당했을 때, 65534개의 IP 주소 중 일부만 사용한다면 나머지 사용하지 않는 IP 주소들이 낭비되어 버린다.

따라서, 이를 해결하기 위해 IP 주소를 사용하는 네트워크 장치 수에 따라 효율적으로 사용할 수 있는 **서브넷(Subnet)** 개념이 등장하게 되었다.

<br>

**서브넷(Subnet)**이란, 하나의 네트워크를 분할한 작은 단위의 네트워크를 말한다. 이제 IP 주소는 `네트워크 ID + 서브넷 ID + 호스트 ID`로 나누어진다.

하지만 이렇게 나누면, 어디까지가 네트워크 ID이고 어디서부터 호스트 ID인지 명확하게 구분할 수 없게 된다. 

이를 위해 **서브넷 마스크(Subnet Mask)**를 사용한다.

- 서브넷 마스크는 연속된 1과 연속된 0으로 구성된다.
- IP 주소의 각 클래스마다 네트워크 ID는 고정되어 있으므로, 서브넷 ID는 호스트 ID에서 빌려와서 사용한다.
- 따라서 **네트워크 ID + 서브넷 ID 부분이 어디까지인가**를 표시하는 것이 서브넷 마스크라고 할 수 있다.

예를 들어, 서브넷 마스크가 `255.255.255.0` 이라고 한다면 `앞 24비트가 네트워크 ID + 서브넷 ID` 이고, `뒤의 8비트가 호스트 ID`라는 것을 의미한다.

따라서 해당 서브넷에서는 8비트의 호스트만큼의 개수인 256개의 IP 주소 범위를 사용할 수 있다는 뜻이다.

<br>

이런식으로 서브네팅을 하게 되면, 특정 기업에 IP 주소 범위를 클래스별로 할당하는 것이 아니라 서브넷 별로 할당할 수 있게 된다.

그러면 기업에서 사용하는 IP 주소의 수만큼 유동적으로 범위를 할당할 수 있게 되는 것이므로 주소 고갈 문제를 더 효율적으로 해결할 수 있다.

서브넷 마스크를 더 편하게 보기 위해 **IP 주소에 Prefix 형태로 붙여서 표기**할 수도 있다.

예를 들어, `192.168.1.0/24` 와 같이 표기하면 `네트워크 ID + 서브넷 ID`가 24비트를 차지한다는 뜻이다. 

서브넷 마스크를 따로 보지 않아도 Prefix 표기를 통해 쉽게 파악할 수 있고, 이를 **CIDR 표기법**이라고도 한다.

<br>

**CIDR(Classless Inter-Domain Routing)**이란, 클래스 없는 도메인 간 라우팅 기법을 의미한다.

즉, 예전에 IP 주소 범위를 고정된 클래스 기반으로 나누던 것과 달리, 더욱 능동적으로 IP 주소 범위를 나누는 것을 말한다.

만약 특정 IP 주소가 `192.168.10.70/26` 라면 `네트워크 ID + 서브넷 ID`가 26비트를 차지한다는 뜻이다.

서브넷 마스크는 255.255.255.192가 되며, 64개의 호스트를 가질 수 있다는 의미이다. 물론 네트워크 주소와 브로드캐스트 주소를 제외하면 62개다.

이렇듯, CIDR은 서브넷과 다른 개념이 아니라 부분집합 관계이며, 서브네팅과 슈퍼네팅을 합친 것을 CIDR이라고 할 수 있다.

<br>

지금까지 IPv4에서의 주소 고갈 문제를 해결하기 위해, 공인 IP와 사설 IP로 나누고 서브넷을 이용하는 등의 방법을 살펴보았다.

하지만 그래도 너무 많이 생겨나는 장비들을 감당할 수 없었고, 그래서 IPv6가 등장하게 되었다.

- `IPv4`는 32비트 기반으로 `2^32개`의 호스트를 생성할 수 있는 반면, `IPv6`는 128비트 기반으로 `2^128개`의 호스트를 생성할 수 있다. (사실상 무한)

- `IPv4`는 .을 이용해 옥텟을 구분했지만, `IPv6`에서는 :을 이용해 수치를 구분한다. (ex. 2001:0db8:85a3:08d3:1319:8a2e:0370:7334)
- `IPv4`는 NAT과 같은 기술을 이용해 주소 변환을 했지만, `IPv6`는 주소 고갈 문제가 없으므로 주소 변환이 필요없다.
- `IPv4`는 유니캐스트, 멀티캐스트, 브로드캐스트가 가능하지만, `IPv6`는 유니캐스트, 멀티캐스트, 애니캐스트가 가능하다.
  - `유니캐스트(Unicast)` : 출발지와 도착지가 명확히 하나로 정해져 있는 1:1 통신 방식을 의미한다. 대부분의 통신은 유니캐스트 방식을 사용한다.
  - `브로드캐스트(Broadcast)` : 도착지 주소가 all로 표시되어 있는 통신 방식을 의미한다. 보통 유니캐스트 통신 전 도착지를 판별하기 위해 사용한다.
  - `애니캐스트(Anycast)` : 동일한 주소를 가진 여러 목적지 중 출발지와 가장 가까운 장비 하나와 통신하는 방식이다.
  - `멀티캐스트(Multicast)` : 그룹 주소를 이용해, 해당 그룹에 속한 다수의 호스트로 패킷을 전송하는 통신 방식이다. 실시간 방송에서 주로 사용한다.

<br>

물리 계층, 데이터 링크 계층, 네트워크 계층 이렇게 세 계층만 있으면 서로 다른 네트워크 간에도 데이터를 주고 받는 것에는 아무 문제가 없다.

**하지만 다른 네트워크에 있는 컴퓨터에 내가 보내고자 하는 데이터가 잘 도착했는지는 어떻게 알 수 있을까?**

**또한, 현재 다른 네트워크에 있는 컴퓨터가 정상적으로 데이터를 받을 수 있는 상태인지 어떻게 알 수 있을까?**

데이터를 단순히 보내는 것에서 끝나지 않고, 전송의 신뢰성을 확보하기 위해서는 전송 계층이 필요하게 되었다.

<br>

### 4) 전송 계층 (Transport layer)

> 도착지에 신뢰할 수 있는 데이터를 전달하는 역할
> 주요 용어 : TCP, UDP, 세그먼트, 포트, 데이터그램

네트워크 계층에서 IP를 통해 데이터를 주고 받을 수 있었다. 이때, 데이터가 한번에 보내지는 것이 아니라 패킷 단위로 쪼개져서 전송된다.

따라서 중간에 패킷이 유실되거나, 패킷이 순서대로 전송되지 않는다면 올바르게 데이터가 표시되지 않을 수 있다.

<br>

전송 계층에서 사용하는 **TCP(Transmission Control Protocol)**는 이런 문제를 해결해 줄 수 있다.

TCP는 **연결형 통신**으로써, 도착지의 컴퓨터와 연결되어 있는지 미리 확인하면서 통신하는 방법이다.

- `연결 지향` : 먼저 연결을 하고나서 데이터를 보냄으로써, 비연결성을 해결한다.
- `데이터 전달 보증` : 정보가 누락되면 누락되었는지 알 수 있다.
- `순서 보장` : 패킷의 도착 순서를 보장한다.

응용 계층으로부터 내려온 데이터에 TCP 헤더를 붙여 캡슐화 한다. 이를 **세그먼트(Segment)**라 하며, TCP의 기본 전송 단위가 된다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/edee242e-6571-40f4-b2a8-32f0c066cdc7)

여기서 출발지 Port 번호와 도착지 Port 번호가 있는 것을 알 수 있다. **포트(Port)**란 애플리케이션을 구분하는 번호를 의미한다.

네트워크 계층에서는 IP 주소를 통해 도착지 장비를 명시할 수 있었다. 하지만 해당 장비 내에서 어떤 애플리케이션으로 데이터를 전송해야 하는지는 알 수 없다.

따라서, 포트 번호를 전송 계층에서 명시하여 애플리케이션을 구분한다. 포트 번호는 0 ~ 65535번까지 사용할 수 있고, 이미 특정 포트 번호는 사용 중이다.

- `SSH` : 22
- `SMTP` : 25
- `DNS` : 53
- `HTTP` : 80
- `HTTPS` : 443
- `POP3` : 110

<br>

**코드 비트**는 출발지와 도착지 간의 연결에 대한 제어 정보를 담는 곳이다. 6비트에 해당하는 코드 비트는 아래와 같이 구성되어 있다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/6e142a10-baad-41e1-ab3d-34f2f490d8ef)

이 중 주로 사용되는 비트는 아래 세 가지이다.

- `SYN` : 연결 요청
- `ACK` : 확인 응답
- `FIN` : 종료 요청

<br>

여기서 TCP의 중요 개념이 등장한다. 바로 코드 비트를 이용한 `3-way handshake`, `4-way handshake`이다.

**3-way handshake**

> 통신을 시작하기 위해, 도착지와 연결이 가능한지 확인하는 작업을 의미한다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/23189f5a-d26b-4a65-9c12-f539a8395d74)

1. 클라이언트는 서버에게 SYN에 1을 담아 보낸다.

2. 서버는 클라이언트의 요청을 허가한다는 응답을 회신하기 위해 ACK에 1을 담아 보낸다. 동시에 서버도 클라이언트와의 연결을 위해 SYN에 1을 담아 같이 보낸다.
3. 클라이언트 역시 허가한다는 응답을 회신하기 위해 ACK에 1을 담아 보낸다. 이후 연결이 수립된다.

<br>

**4-way handshake**

> 통신을 종료하기 위해, 도착지에게 연결 끊음을 알리는 작업을 의미한다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/76b2be7a-2216-4550-9abc-98009e4be3a5)

1. 클라이언트는 서버에게 FIN에 1을 담아 보낸다.
2. 서버는 연결 종료 응답으로 ACK에 1을 담아 반환한다.
3. 서버는 클라이언트에게 FIN에 1을 담아 보낸다.
4. 클라이언트는 연결 종료 응답으로 ACK에 1을 담아 반환한다.

<br>

3-way handshake와 4-way handshake를 통해 잘 연결 했다면, 이제 데이터를 주고 받을 때 어떻게 유실을 방지하고 순서를 보장하는지 알아보자.

이는 **일련 번호**와 **확인 응답 번호**를 통해 할 수 있다. 데이터를 실제로 주고 받을 때 사용하는 부분이다.

<img width="500" alt="image" src="https://github.com/backend-team-study/cs-study/assets/49775540/21190e65-5f7a-420a-82da-1c3ec807a931">

두 번호의 의미는 송신 측과 수신 측에 따라 다르다. 한번에 `200바이트`의 데이터를 전송한다는 가정하에 의미는 다음과 같다.

- **송신 측**
  - `일련 번호` : 현재 보내는 데이터의 시작 번호 (3001번에서 시작하는 데이터)
  - `확인 응답 번호` : 전체 데이터의 끝 번호 (4001번까지 데이터를 보낼 예정)
- **수신 측**
  - `일련 번호` : 전체 데이터의 끝 번호 (4001번까지 데이터를 받을 예정)
  - `확인 응답 번호` : 현재까지 받은 데이터의 끝 번호 (현재 3201번까지 데이터를 받음)

만약 일련 번호와 확인 응답 번호를 확인했을 때, 패킷이 유실되거나 순서가 맞지 않는 경우 재전송 하게 되어 있다.

<br>

TCP는 위와 같이 전송의 흐름을 제어할 수 있는 기능을 내장하고 있다. 이를 **전송 제어 기법**이라고 하며 크게 세 가지가 존재한다.

**흐름 제어 (Flow Control)**

>  수신 측의 데이터 처리 속도를 파악하여, 송신 측에서 얼마나 빠르게 어느 정도의 데이터를 전송할지 제어하는 것

1. Stop and Wait 방식
   - 매번 전송한 데이터에 대해 확인 응답을 받고, 그 다음 데이터를 전송하는 방법을 의미한다.
2. Sliding Window 방식
   - 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답없이 데이터를 전송할 수 있게 하여 흐름을 동적으로 조절하는 방법을 의미한다.
   - TCP 헤더에 `윈도우 크기`라는 부분이 있는데, 얼마나 많은 용량의 데이터를 버퍼에 저장할 수 있는지를 의미한다.
   - 따라서 송신 측은 수신 측의 윈도우 크기를 보고 버퍼의 한계 크기를 예측하여, 그만큼의 데이터는 확인 응답 없이 연속해서 보낼 수 있다.

<br>

**오류 제어 (Error Control)**

> 통신 도중에 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우에 제어하는 것

1. Go Back N 방식
   - 어느 데이터로부터 오류가 발생했는지 파악하여, 그 부분만 다시 순서대로 보내는 방법을 의미한다.
2. Selective Repeat 방식
   - 오류가 발생한 데이터만 재전송하고, 그 전에 받았던 순서가 잘못된 데이터 버퍼를 재정렬하는 방법을 의미한다.

Go Back N은 오류가 난 곳부터 다시 순서대로 모두 보내라는 것이고, Selective Repeat은 오류가 난 부분만 다시 보내라하고 알아서 정렬하는 것을 말한다.

<br>

**혼잡 제어 (Congestion Control)**

> 네트워크 내에 패킷의 수가 과도하게 증가하는 현상으로 인한 혼잡 상황을 방지하고 제거하는 것

하나의 라우터에 데이터가 몰릴 경우 데이터를 처리할 수 없게 된다. 이때 송신 측은 재전송을 하게 되는데 그러면 혼잡이 가중되어 오버플로우가 발생한다.

따라서 송신 측에서 이러한 혼잡을 방지하고자 전송 속도를 줄이는 것을 혼잡 제어라 한다.

흐름 제어는 단순히 송신 측과 수신 측의 전송 속도를 다루지만, 혼잡 제어는 더 넓은 네트워크 관점에서의 전송 문제를 다룬다는 차이가 있다.

1. AIMD(Additive Increase / Multiplicative Decrease, 합 증가 / 곱 감소 알고리즘) 방식
   - 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가하며 전송하고, 전송에 실패하면 윈도우 크기를 반으로 줄이는 방식이다.
   - 윈도우 크기를 조금씩 늘리기 때문에, 네트워크 대역폭을 제대로 활용하기까지 오래걸린다는 단점이 존재한다.
2. Slow Start (느린 시작) 방식
   - 윈도우 크기를 1이 아닌 지수적으로 증가(2, 4, 6, 8 ...)시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식이다.
   - 보낸 데이터의 ACK가 도착할 때마다 윈도우를 증가시키므로 처음에는 느리게 증가하나, 시간이 갈 수록 점점 빠르게 윈도우가 증가한다.
3. Fast Retransmit (빠른 재전송) 방식
   - 수신자가 패킷이 순서대로 도착하지 않는 경우, 순서대로 잘 도착한 마지막 패킷의 다음 순번 (즉 수신해야 하는 패킷의 순번)을 ACK에 적어서 보낸다.
   - 중복 ACK를 3개 받으면 TCP timeout 이전이라 하더라도 바로 해당 패킷을 재전송한다. (빠른 재전송)
4. Fast Recovery (빠른 회복) 방식
   - 혼잡 상태가 되면 윈도우 크기를 1로 줄이지 않고, 반으로 줄인 후 선형 증가하는 방식이다.
   - 혼잡 상황을 한번 겪고 나서부터는 AIMD 방식이 된다.

<br>

전송 계층에는 TCP이외에 **UDP(User Datagram Protocol)**도 존재한다.

TCP는 3-way handshake와 같이 연결을 위한 확인 작업이나 재전송 제어와 같은 것들을 통해 신뢰성을 확보하지만, 그만큼 속도가 느리다.

하지만 UDP는 **비연결형 통신**이므로, TCP처럼 추가적인 시간이 걸리는 작업을 따로 하지 않아서 속도가 빠르다.

데이터를 효율적으로 빠르게 보내는 것에 초점이 맞춰져 있으므로, 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에서 많이 사용한다.

응용 계층으로부터 내려온 데이터에 UDP 헤더를 붙여 캡슐화 한다. 이를 **데이터그램(Datagram)**이라 하며, UDP의 기본 전송 단위가 된다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/e1e3a61f-3da9-41fd-9f1f-5bd7332e4f0d)

UDP 헤더는 TCP와 달리 확인 작업이 없기 때문에 간단하게 구성되어 있다. 

따라서 브로드캐스트의 경우 UDP가 유리한데, TCP는 모든 컴퓨터와 일일히 통신 연결 작업을 해야하지만, UDP는 그럴 필요가 없기 때문이다.



![image](https://github.com/backend-team-study/cs-study/assets/49775540/a2b8cc35-824b-4323-b3c3-f6cfcceb6c4c)

<br>

### 5) 세션 계층 (Session layer)

> 네트워크의 양쪽 연결을 관리하고 지속하는 역할

주로 **TCP/IP 세션을 만들고 유지**하며, 세션이 종료되거나 전송이 중단 될 시 복구하는 기능을 한다.

- 세션이란, 일정 시간 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지하는 기술을 의미한다.
- 예를 들어 클라이언트가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 이를 하나의 세션으로 간주한다.

<br>

### 6) 표현 계층 (Presentation layer)

> 데이터의 변환이나 압축, 암호화 역할

주로 서로 다른 컴퓨터에서 사용하는 데이터 형식의 차이를 없애기 위한 변환을 수행하거나, 압축 및 데이터 암호화를 수행한다.

<br>

### 7) 응용 계층 (Application layer)

> 사용자가 애플리케이션을 통해 네트워크에 접근할 수 있도록 하는 역할

사용자의 작업 목적에 따른 프로토콜을 통해 네트워크 서비스를 제공한다. (HTTP, FTP, SMTP, DNS 등)

<br>

---

<br>

## 1.2. TCP/IP 4계층

![image](https://github.com/backend-team-study/cs-study/assets/49775540/7e86e952-bece-4b05-b8a6-8e8e7abf4d95)

OSI 7계층은 이론적인 성향이 강한 모델이다. 따라서 요즘은 OSI 7계층의 일부를 계승한 TCP/IP 4계층을 실질적으로 사용한다.

내용 상의 변화보다는, 비슷한 역할을 하는 계층끼리 통합했다고 보면 된다.

- 5 ~ 7에 해당하는 세션, 표현, 응용 계층이 Application layer로 합쳐졌다.
- 1, 2에 해당하는 물리, 데이터 링크 계층이 Network Access layer로 합쳐졌다.

<br>

---

<br>

## 1.3. 질문 모음

1. OSI 7계층과 같이 계층별로 통신 과정을 나눈 이유는 무엇인가요?
2. OSI 7계층을 통한 통신 과정에서의 캡슐화와 역캡슐화는 어떤 것을 의미하나요?
3. MAC 주소는 어떤 것을 의미하나요? 어떤 과정에서 활용되나요?
4. 스위치가 MAC 주소를 어떤 식으로 관리하는지, 실제로 특정 컴퓨터에서 데이터를 보내는 상황을 가정해서 말씀해주실 수 있나요?
5. 데이터 링크 계층에서 데이터의 송수신 시 충돌을 방지하기 위해 어떤 방식으로 해결할 수 있나요?
6. 허브와 스위치, 그리고 라우터의 차이를 알고 있나요?
7. IP 주소는 어떤 것을 의미하나요? MAC 주소가 있는데도 IP 주소를 별도로 부여하는 이유는 무엇일까요?
8. IPv4와 IPv6의 차이는 무엇일까요? IPv6는 왜 등장하게 되었나요?
9. 서브넷 마스크는 어떤 역할을 하나요?
10. 공인 IP와 사설 IP의 차이는 무엇일까요? 사설 IP만으로 통신하면 안되는 이유는 무엇일까요? 그리고 이를 어떤 기술을 통해 해결할 수 있나요?
11. CIDR이란 무엇인가요? 기존 IP 주소 체계의 어떤 한계점을 극복하기 위해 등장한 개념인가요?
12. 통신 방식에서 멀티캐스트와 애니캐스트 모두 일대다 통신인데, 어떤 차이점이 있을까요?
13. 포트 번호란 무엇일까요? IP 주소가 있는데도 포트 번호를 명시하는 이유는 무엇일까요?
14. TCP의 3-way-handshake와 4-way-handshake의 개념에 대해 설명해주세요. 이를 수행하면 어떤 장점이 있을까요?
15. TCP에서 데이터의 유실이나 순서 보장을 위해 어떤 방법을 적용하나요?
16. TCP의 흐름 제어 기법에 대해 설명해주세요. 해당 기법을 위해 대표적으로 적용하는 방식 하나를 자유롭게 설명해주세요.
17. TCP의 혼잡 제어 방식 중, 빠른 재전송 방식에 대해 설명해주세요.
18. UDP란 무엇인가요? TCP와는 어떤 차이점이 존재하나요?
19. OSI 7계층과 TCP/IP 4계층은 어떤 차이가 있나요?
