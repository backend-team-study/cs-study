# 02 HTTP 상태코드, 메서드, DNS

# 1. HTTP

## HTTP status cod

### **✅1XX: Informational(정보 제공)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 서버 측면에서의 의미 |
| --- | --- | --- | --- |
| 1XX | Informational | 정보 제공 | 진행 중임을 의미하는 응답코드입니다. 현재까지의 진행상태에 문제가 없으며, 클라이언트가 계속해서 요청을 하거나 이미 요청을 완료한 경우에는 무시해도 되는 것을 알려줍니다. |
| 100 | Continue | 계속 | 계속 진행하라.클라이언트는 요청 헤더에 ‘Expect: 100-continue’를 보내고 서버는 이를 처리할 수 있으면 이 코드로 응답합니다. |
| 101 | Switching Protocols | 프로토콜 전환 | 프로토콜을 전환하라.프로토콜을 Websocket 프로토콜 전환 시에 사용된다. |
| 102 | Processing | 처리중 | 이 응답 코드는 서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로 된 응답을 알려줄 수 없음을 알려줍니다. |

### **✅2XX: Success(성공)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 서버 측면에서의 의미 |
| --- | --- | --- | --- |
| 2XX | Success | 성공 | 성공적으로 처리한 경우 사용됩니다. |
| 200 | OK | 성공 | 요청이 성공적으로 되었습니다. 정보는 요청에 따른 응답으로 반환됩니다. |
| 201 | Created | 생성됨 | 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다. 이 응답은 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라옵니다. 응답 헤더 Location에 새로운 리소스에 대한 URI를 담아줍니다. |
| 202 | Accepted | 허용됨 | 요청을 수신하였지만, 그에 응하여 행동할 수 없습니다. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않습니다. 이것은 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌습니다. |
| 203 | Non-AuthoritativeInformation | 신뢰할 수 없는정보 | 응답 헤더가 오리지널 서버로부터 제공된 것이 아니다. 프록시 서버가 응답 헤더에 주석을 덧붙인 경우가 하나의 예입니다. 
위 코드 대신 214 사용 권장 |
| 204 | No Content | 콘텐츠 없음 | 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없다. 응답에는 헤더만 있고 바디는 없습니다. DELETE 요청에 대한 응답에 많이 사용됩니다. |
| 205 | Reset Content | 콘텐츠 재설정 | 처리를 성공하였고 브라우저의 화면을 리셋하라. 예를 들어 브라우저가 입력 폼을 보여 주고 있을 때 이 응답 코드를 받으면 브라우저는 모든 입력 항목을 리셋하고 재입력할 수 있는 상태가 됩니다. |
| 206 | Partial Content | 일부 콘텐츠 | 콘텐츠의 일부만을 보낸다. 응답 헤더의 Content-Range에 응답 콘텐츠의 범위를 기록합니다. 예를 들어 1,500 바이트의 리소스 중에서 처음의 500 바이트만을 보낼 때 사용할 수 있습니다. |
| 207 | Multi-Status | 다중 상태 | (WebDAV) 처리 결과의 스테이터스가 여러 개이다. 207 응답은 성공을 뜻하지만, 각각의 처리 결과가 성공인지는 바디를 봐야 알 수 있습니다. |
| 208  | Already Reported | 이미 보고됨 | (WebDAV) PROPFIND라는 HTTP 메서드에 대한 응답 속성. 207 코드를 먼저 반환하고 내부 바디에 이미 반환된 정보가 있다면 208을 담아준다. |
| 218 | This is fine | 아파치 비공식 응답 코드 (난 괜찮아~) | 어디선가 오류가 발생했지만 Apache 서버는 괜찮다는 의미 |
| 226 | IM Used | GET 요청에 대한 의무를 다 했는데 인스턴스 조작이 적용되었음 | HTTP Delta Encoding 을 통해 캐시와 다른 부분에 대해서만 데이터를 보낸 경우에 사용.
캐시와 같다면 보통 304 (Not-Modified) 반환  |

```
[ WebDAV 란? ]

WebDAV(Web Distributed Authoring and Vesioning)는 하이퍼텍스트 전송 프로토콜의 확장으로, 웹 서버에 저장된 문서와 파일을 읽고 쓰기가 가능한 매개체로 만들어서, 편집하고 관리하는 사용자들 사이에 협업을 손쉽게 만들어 준다.
```

### **✅3XX: Redirection(리다이렉션)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 서버 측면에서의 의미 |
| --- | --- | --- | --- |
| 3XX | Redirection | 리다이렉션 | 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다. |
| 300 | Multiple Choices | 여러 선택항목 | 선택 항목이 여러 개 있다.지정한 URI에 대해서 콘텐츠 협상을 수행한 결과 서버에서 콘텐츠를 결정하지 못하고 클라이언트에게 복수 개의 링크를 응답할 때 사용합니다. |
| 301 | Moved Permanently | 영구 이동 | 지정한 리소스가 새로운 URI로 이동하였다. 
리다이렉션 되면 요청 메서드가 GET으로 변경되고 본문이 제거될 수 있기 때문에 301 코드는 GET 또는 HEAD에 대해서만 권장 |
| 302 | Found | 다른 위치 찾음 | 요청한 리소스를 다른 URI에서 찾았다. 301과 달리 브라우저에 따라 본문 변경에 대한 작업 수행이 달라지는 불확실성을 가진다. 이러한 불확실성 때문에 303, 307 코드가 추가되었다. |
| 303 | See Other | 다른 위치 보기 | 다른 위치로 요청하라. 요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할 수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드입니다. |
| 304 | Not Modified | 수정되지 않음 | 이것은 캐시를 목적으로 사용됩니다. 이것은 클라이언트에게 응답이 수정되지 않았음을 알려주며, 그러므로 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있습니다. 바디가 없습니다. |
| 305 | Use Proxy | 프록시 사용 | 지정한 리소스에 액세스하려면 프록시를 통해야 한다. 응답 헤더 Location에 프록시의 URI를 기록합니다. |
| 306 | (Unused) |  | 예전 버전에서 사용하다가 현재는 사용하지 않는 상태 코드입니다. HTTP 1.1 이전 버전에서 사용되었습니다. |
| 307 | Temporary Redirect | 임시 리다이렉션 | 임시로 리다이렉션 요청이 필요하다. 요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 
302와 달리 본문이 변하지 않고 유지된다.
클라이언트가 요청한 리소스가 다른 URI에 있으며, 이전 요청과 동일한 메서드를 사용하여 요청해야 할 때 사용. |
| 308 | Permanent Redirect |  영구 리다이렉션 | 301과 기능은 동일하지만, 영구 리다이렉트 시 요청 메서드와 본문을 유지한다.
클라이언트가 요청한 리소스가 다른 URI에 있으며, 이전 요청과 동일한 메서드를 사용하여 요청해야 할 때 사용. |

> 301 vs 302
> 

301과 302는 영구냐 일시적이냐의 차이만 있는 것 같지만 실제로는 다양한 차이점을 지니고 있다.

1. 검색 엔진에서의 차이

검색 엔진의 경우 301 (영구) 상태코드를 확인하면 앞으로 기존의 주소가 아닌 새로운 주소에 대해서만 정보 수집을 실시한다. 이는 크롤링, 검색 노출도에 영향을 미치는데 이를 악용하여 높은 랭크를 가진 URL을 구입하고 302를 이용하여 광고 사이트로 리다이렉션 시키는 부정사례가 자주 있다. 그래서 구글은 302를 자주 사용하거나 부적절하게 사용할 경우 페널티를 부과한다.

1. 브라우저 캐싱 차이

301의 경우 브라우저 내에서 알아서 캐싱이 된다. 즉, 처음 리다이렉션 요청 이후에는 301 응답을 거치지 않고 바로 브라우저에서 리다이렉션 해버린다. 

302의 경우도 브라우저 캐싱이 가능하지만, `Cache-control` 이나 `Expire` 헤더를 명시해주어야 한다. 따라서 만약에 필요에 의해서 서버 로직을 거치고 리다이렉트를 시켜야 하는 경우는 302가 적절하다.

# **✅4XX: Client Error(클라이언트 에러)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 서버 측면에서의 의미 |
| --- | --- | --- | --- |
| 4XX | Client Error | 클라이언트 에러 | 클라이언트의 요청에 오류가 있다. |
| 400 | Bad Request | 잘못된 요청 | 요청의 구문이 잘못되었다.클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다. |
| 401 | Unauthorized (참고로 Unauthenticated 가 알맞다) | 인증 안됨 | 지정한 리소스에 대한 액세스 권한이 없다.응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다. |
| 402 | Payment Required | 결제 필요 | 지정한 리소스를 액세스하기 위해서는 결제가 필요하다. 이 응답 코드는 실제로는 사용되지 않습니다. |
| 403 | Forbidden | 권한 없음 | 지정한 리소스에 대한 액세스가 금지되었다.
인증 자격은 증명되었으나, 접근 권한이 불충분하여 서버가 요청의 승인을 거부했음을 의마한다. |
| 404 | Not Found | 찾을 수 없음 | 지정한 리소스를 찾을 수 없다.
무조건 404라고 리소스가 존재하지 않는 것은 아니다. 인증되지 않은 사용자에게 리소스를 숨기기 위해 403 대신 404를 보내는 경우도 있따. |
| 405 | Method Not Allowed | 허용되지 않은메소드 | 요청한 URI가 지정한 메소드를 지원하지 않는다.응답 헤더 Allow에 이 URI가 지원하는 메소드 목록을 기록합니다.
GET과 HEAD는 필수 메서드로 처리되기 때문에 405로 제한할 수 없다. |
| 406 | Not Acceptable | 수용할 수 없음 | 클라이언트가 Accept-* 헤더에 지정한 항목에 관해 처리할 수 없다.응답 바디에는 300 응답처럼 서버가 수용 가능한 다른 선택지 리스트가 기록됩니다.
현업에서는 잘 사용하지 않는다. |
| 407 | Proxy AuthenticationRequired | 프록시 인증 필요 | 클라이언트는 프록시 서버에 인증이 필요하다. 프록시 서버의 응답 헤더 Proxy-Authenticate에 필요한 인증 방식을 지정합니다. |
| 408 | Request Timeout | 요청 시간초과 | 요청을 기다리다 서버에서 타임아웃하였다. |
| 409 | Conflict | 충돌 | 서버가 요청을 수행하는 중에 충돌이 발생하였다. 예를 들어 사용자명을 new_name으로 변경하려 하였지만, 서버에 이미 new_name이라는 사용자가 존재하는 경우입니다. 응답 헤더 Location에는 충돌이 발생한 리소스의 URI를 기록합니다.
사실 충돌이라는 것은 추상적인 오류 현상이기 때문에 여타 4XX 상태 코드에 속하지 않은 애매한 오류의 상황들을 처리하는 데 이용된다고 본다. |
| 410 | Gone | 사라짐 | 지정한 리소스가 이전에는 존재하였지만, 현재는 존재하지 않는다. 예를 들어 기간이 한정된 프로모션 사이트가 사라진 경우 사용할 수 있는 응답 코드입니다. |
| 411 | Length Required | 길이 필요 | 요청 헤더에 Content-Length를 지정해야 한다. |
| 412 | Precondition Failed | 사전 조건 실패 | If-Match와 같은 캐시에 대한 조건부 요청에서 지정한 사전 조건이 서버와 맞지 않는다. |
| 413 | Request EntityToo Large | 요청 객체가너무 큼 | 요청 메시지가 너무 크다. 서버는 접속을 끊습니다. |
| 414 | Request-URIToo Large | 요청 URI가너무 긺 | 요청 URI가 너무 길다. |
| 415 | UnsupportedMedia Type | 지원되지 않는미디어 유형 | 클라이언트가 지정한 미디어 타입을 서버가 지원하지 않는다. 예를 들어 서버가 지원하는 이미지는 JPG, PNG뿐인데 클라이언트가 GIF 형식의 이미지를 요청하는 경우입니다. |
| 416 | Range Not Satisfiable | 처리할 수 없는요청 범위 | 클라이언트가 지정한 리소스의 범위가 서버의 리소스 사이즈와 맞지 않는다. |
| 417 | Expectation Failed | 예상 실패 | 클라이언트가 지정한 Expect 헤더를 서버가 반환할 수 없을 때. |
| 418  | I’m a teapot | 만우절 | 만우절 농담이었던 하이퍼 텍스트 커피 포트 제어 규약 (Hyper Text Coffe Pot Control Protocol) |
| 420 | Method Failure or Enhance your calm | 니 잘못이야! | 클라이언트 오류를 나타내기 위해 서버에서 반환하는 비공식 클라이언트 오류 |
| 421 | Misdirected Request | 잘못된 방향의 요청 | 의도하지 않은 요청을 받아 서버가 응답을 생성할 수 없음 |
| 422 | Unprocessable Entity | 처리할 수 없는 엔티티 | (WebDAV) 클라이언트가 송신한 XML이 구문은 맞지만, 의미상 오류가 있다. |
| 423 | Locked | 잠김 | (WebDAV) 지정한 리소스는 잠겨있다. |
| 424 | Failed Dependency | 의존 관계로 실패 | (WebDAV) 다른 작업의 실패로 인해 본 요청도 실패하였다. |
| 426 | Upgraded Required | 업그레이드필요함 | 클라이언트의 프로토콜의 업그레이드가 필요하다. 응답에 Upgrade 헤더를 보내 필요한 프로토콜을 알려 줍니다.
ex) HTTP 1.1 버전은 받지 않고 HTTP 2 이상만 받는다고 할 때 |
| 428 | Precondition Required | 사전 조건 필요함 | If-Match와 같은 사전조건을 지정하는 헤더가 필요하다. If-Match 헤더가 누락됐을 경우 |
| 429 | Too Many Requests | 너무 많은 요청 | 클라이언트가 주어진 시간 동안 너무 많은 요청을 보냈다. 요청의 속도를 제한할 때 사용합니다.  응답에 Retry-After 헤더를 보내 얼마나 기다릴지를 알려 줄 수 있습니다. |
| 431 | Request Header Fields Too Large | 너무 큰 헤더 | 헤더의 길이가 너무 크다. 헤더의 전체 크기가 크거나 또는 하나의 헤더가 매우 큰 경우입니다. 보통 Referer URL이 길거나 쿠키 항목이 많은 경우입니다. |
| 444 | Connection Closed Without Response | 응답 없이 연결 닫음 | (NGINX) 응답을 보내지 않고 연결을 종료하였다. 보통 악의적인 요청에 대해서 사용하며 클라이언트에서는 응답을 볼 수 없고 Nginx 로그에는 나타납니다. |
| 451 | Unavailable For Legal Reasons | 법적 사유로 불가 | 법적으로 문제가 있는 리소스를 요청하였다. |

> 304와 412 상태 코드 차이
> 

304 Not Modified와 412 Precondition failed 는 웹 브라우저의 캐시 관련 헤더와 연관된 상태 코드로서, 클라이언트의 리소스 수정 상태와 서버의 리소스 수정 상태가 다르면 응답하게 된다.

- 304 응답은 GET 과 HEAD 메서드에만 동작한다.
- 412 응답은 위를 제외한 POST, PUT, PATCH 등의 메서드에만 동작한다.

### **✅5XX: Server Error(서버 에러)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 서버 측면에서의 의미 |
| --- | --- | --- | --- |
| 5XX | Server Error | 서버 에러 | 클라이언트의 요청은 유효한데 서버가 처리에 실패하였다. |
| 500 | Internal Server Error | 내부 서버 오류 | 서버에 에러가 발생하였다. 클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다. |
| 501 | Not Implemented | 구현되지 않음 | 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다. |
| 502 | Bad Gateway | 불량 게이트웨이 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.
보통은 요청 폭주로 서버에 통신장애가 발생하였을 경우 발생
인터넷상의 서버가 다른 서버로부터 유효하지 않은 응답을 받은 경우에도 발생 |
| 503 | Service Unavailable | 서비스 제공불가 | 현재 서버에서 서비스를 제공할 수 없다.보통은 서버의 과부하나 서비스 점검 등 일시적인 상태입니다. |
| 504 | Gateway Timeout | 게이트웨이 시간초과 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 타임아웃이 발생하였다. |
| 505 | HTTP Version Not Supported | HTTP 버전미지원 | 클라이언트가 요청에 사용한 HTTP 버전을 서버가 지원하지 않는다. |
| 506 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |
| 507 | Insufficient Storage | 용량 부족 | (WebDAV) 서버에 저장 공간 부족으로 처리에 실패하였다. |
| 512 ~ 599 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

## HTTP method

### GET

- 리소스 조회 메서드 (READ)
- 전달하고 싶은 데이터는 쿼리스트링을 통해서 전달
- 쿼리스트링 외에 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 서버에서 따로 구성해야 하기 때문에 지원하지 않는 곳이 많아서 권장되지 않음
- **조회할 때 POST도 사용할 수 있지만, GET 메서드는 캐싱이 가능하기 때문에 GET을 사용하는 것이 유리하다**

### POST

- 전달한 데이터 처리/생성 요청 메서드 (CREATE)
- 메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버는 요청 데이터를 처리하여 업데이트
- 전달된 데이터로 주로 신규 리소스 등록, 프로세스 처리에 사용
- 만일 데이터를 GET 하는 데 있어, JSON으로 조회 데이터를 넘겨야 하는 애매한 경우 POST를 사용

### PUT

- 리소스를 대체(수정) 하는 메서드 (UPDATE)
- 만일 요청 메세지에 리소스가 있으면 덮어쓰고, 없으면 새로 생성한다.
- 데이터를 대체해야 하니, 클라이언트가 리소스의 구체적인 전체 경로를 지정해 보내주어야 한다.
    - ex ) POST /members : 멤버 새로 추가
    - PUT /members/13 : 13번째 멤버 수정
    

### PATCH

- 리소스 일부 부분을 변경하는 메서드 (UPDATE)
- 만일 PATCH를 지원하지 않는 서버에서는 대신 POST를 사용할 수 있다.

### DELTE

- 리소스 제거하는 메서드 (DELTE)
- 상태코드는 대부분 200을 사용하고 상황에 따라 `204`를 사용한다.

### HEAD

- GET과 동일하지만 서버에서 바디를 Return 하지 않음
- 응답의 상태 코드만 확인할 때와 같이 리소스를 받지 않고 오직 찾기만 원할 때 사용 (일종의 검사 용도)
- 서버의 응답 헤더를 봄으로써 리소스가 수정되었는지 확인 가능

### TRACE

- 이 메서드도 일종의 검사용 → `나의 요청 패킷이 변조되었는지 유무를 확인하기 위함`
- 서버에 도달했을 때의 최종 패킷의 요청 패킷 내용을 응답 받을 수 있다.
- 요청의 최종 수신자는 반드시 송신자에게 200 응답의 내용(Body)로 수신한 메세지를 반송해야 한다.
- 최초 클라이언트의 요청에는 바디가 포함될 수 없다.

![Untitled](02%20HTTP%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3,%20DNS%20069753a082d240d899258ec16efd7e9a/Untitled.png)

### OPTION

- 예비 요청에 사용되는 메서드
- 예비 요청이란 본 요청을 하기 전에 안전한지 미리 검사하는 것이라고 보면 된다
- 서버의 `지원 가능한 HTTP 메서드와 출처를 응답 받아 CORS` 정책을 검사하기 위한 요청이다.

![Untitled](02%20HTTP%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3,%20DNS%20069753a082d240d899258ec16efd7e9a/Untitled%201.png)

## DNS

![Untitled](02%20HTTP%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3,%20DNS%20069753a082d240d899258ec16efd7e9a/Untitled%202.png)

도메인 네임 시스템은 호스트의 도메인 네임을 네트워크 주소 (IP) 로 변환하거나, 그 반대의 역할을 수행하는 시스템이다.

### 동작 과정

1. 웹 브라우저에 [www.steadies.kr](http://www.steadies.kr) 을 입력하면 먼저 PC에 저장된 Local DNS (기지국 DNS 서버) 에게 “www.steadies.kr” 이라는 도메인 네임에 대한 IP 주소를 요청한다. Local DNS에는 해당하는 주소가 있을 수도 있고 없을 수도 있다. 만일 예전에 접속했던 전적이 있다면 Local DNS에 접속 정보가 캐싱되어있기 때문에 바로 주소를 반환하고 종료된다.

> Local DNS 란?
> 
> 
> 기본적으로 인터넷을 사용하기 위해 IP를 할당해주는 통신사의 기지국 DNS 서버를 말한다.
> 

1. 해당하는 주소를 찾아내기 위해 다른 DNS 서버들과 통신 (DNS 쿼리) 을 시작한다. 최우선적으로 Root DNS 서버에게 주소를 요청한다.
2. Root DNS 서버에도 존재하지 않으면 TLD DNS (Top Level DNS) 에게 요청한다. TLD DNS 에서는 `.com` 혹은 `.co.kr`과 같은 국가 도메인, 최상위 도메인을 관리한다.
3. TLD DNS에도 존재하지 않으면 Authoritative DNS 서버에게 다시 주소를 요청한다.

> Authoritative DNS
> 
> 
> 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버. 일반적으로 ‘네임서버’를 말한다.
> 
1. Authoritative DNS 는 Local DNS 서버에게 IP 주소를 응답하고 Local DNS는 해당 주소를 캐싱하여 다음 요청이 있을 시 응답할 수 있도록 IP 주소를 단말(PC)에 전달해준다.

### DNS 사용 시 주의할 점

DNS 캐시를 통해서 좀 더 빠른 응답속도를 얻을 수 있지만 문제점도 존재한다. DNS 캐시정보가 해킹, 바이러스 등에 의해 변조될 수 있기 때문인데, 특정 도메인이 해킹 사이트 IP 주소로 변경되는 문제가 발생할 수 있다. 그래서 주기적으로 캐싱된 DNS 를 정리해 줄 필요가 있다.