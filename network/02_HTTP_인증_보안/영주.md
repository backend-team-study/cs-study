# 02. HTTP, 인증, 보안

> 김영주

<br>

## 2.1. HTTP

> HTTP (HyperText Transfer Protocol)은 하이퍼미디어 문서를 전송하기 위한 애플리케이션 계층 프로토콜을 의미한다.

- 웹 브라우저와 웹 서버 간의 통신을 위해 설계 및 고안되었다.
- 클라이언트가 요청을 하고, 서버가 응답을 하는 `클라이언트-서버 모델`을 따른다.
- `무상태(Stateless)` 프로토콜이므로, 서버가 요청 간 어떠한 데이터도 유지하지 않는다.

<br>

### HTTP 메시지(Message)

![image](https://github.com/backend-team-study/cs-study/assets/49775540/65dea68c-fe66-437c-90d4-4d53cab958ff)

- HTTP 애플리케이션 간에 주고받은 데이터의 블록들을 의미한다.
- `요청 메시지`와 `응답 메시지`로 나눌 수 있다. 이들은 각각 `시작줄, 헤더, 빈줄, 본문`으로 나눌 수 있다.
  - **요청 메시지**
    - `시작 줄` : 메서드, 요청 URL, 버전
    - `헤더` : 일반 헤더, 요청 헤더
    - `본문` : 요청 시 서버로 보내는 데이터
  - **응답 메시지**
    - `시작 줄` : 버전, 상태 코드, 사유 구절
    - `헤더` : 일반 헤더, 응답 헤더
    - `본문` : 응답 시 클라이언트로 보내는 데이터

<br>

### HTTP 메서드(Method)

![image](https://github.com/backend-team-study/cs-study/assets/49775540/5e117cae-d138-408b-80c7-5bb2e8a1e177)

- HTTP 요청 시, 리소스에 어떠한 행동을 하기 원하는지를 지시하는데 사용한다.
- `GET` : 서버에게 **리소스를 달라고** 요청하기 위해 사용한다.
  - 주로 쿼리 파라미터를 통해 데이터를 전달한다. Body에 데이터를 넣을 수도 있지만 비권장된다.
- `POST` : 서버에 입력 **데이터(주로 HTML Form 데이터)를 전송**하는데 사용한다.
  - 데이터를 주로 Body에 넣어 전달한다.
- `PUT` : 서버에 새로운 리소스를 만들거나, 이미 존재한다면 교체하는데 사용한다.
- `HEAD` : GET처럼 행동하지만, 서버는 응답으로 **헤더만**을 돌려준다.
  - 리소스를 가져오지 않고도 타입 등 정보를 알아내는데 사용한다.
  - 응답의 상태 코드를 통해, 리소스가 존재하는지 확인하는데 사용한다.
  - 헤더를 확인하여 리소스가 변경되었는지 검사하는데 사용한다.

- `DELETE` : 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청하는데 사용한다.

- `OPTIONS` : 서버에게 여러 가지 종류의 지원 범위에 대해 물어보는데 사용한다.
  - 특정 리소스에 대해 어떤 HTTP 메서드가 지원되는지 물어볼 수 있다. 응답 메시지에서 Allow 헤더를 통해 보여준다.
  - 주로 **예비 요청(Preflight)**에 사용된다. 서버가 지원하는 메서드를 응답 받아 CORS 정책을 검사하는데 사용된다.

- `TRACE` : 클라이언트가 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려주기 위해 사용한다.
  - 요청이 여러 프록시를 거쳐서 의도한 연쇄를 거쳐가는지 검사 및 진단하는 용도로 사용한다.
- `CONNECT` : 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해 사용한다.
  - 주로 SSL/TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해 사용한다.
  - 클라이언트와 서버가 SSL 통신을 할 때, 생성된 Key는 보안을 위해 프록시가 모르도록 해야한다. 따라서 CONNECT 요청을 통해, 프록시는 단순히 데이터 전달만을 수행하게 하여, 클라이언트와 서버 양자간 직접 통신을 할 수 있는 터널링을 맺게된다.

<br>

**안전성, 멱등성, 캐시 가능성**

![image](https://github.com/backend-team-study/cs-study/assets/49775540/82ac7507-8373-4e52-b5ae-affd6448b0c1)

- `안전성` : 요청의 결과로 서버에 어떠한 작용도 없는 경우를 의미한다.
  - **GET, HEAD, OPTIONS, TRACE** 메서드는 요청의 결과로 인해 서버에서 일어나는 일이 없으므로 안전하다고 할 수 있다.
- `멱등성` : 여러 번 동일한 요청을 보냈을 때, 서버에 미치는 의도된 영향이 동일한 경우를 의미한다.
  - **GET, HEAD, PUT, DELETE, OPTIONS, TRACE** 메서드는 여러 번 요청해도 서버의 리소스에 변화가 없으므로 멱등하다고 할 수 있다.
  - 단, 이는 사용자 요청에 의한 리소스만을 고려한 것이므로, 구현에 따른 부작용은 고려하지 않는다.
  - PATCH의 경우는, 기존 리소스에 무언가를 추가하는 용도로도 사용할 수 있으므로 멱등하지 않다. [(참고)](https://www.inflearn.com/questions/110644/comment/84271)

- `캐시 가능성` : 응답 결과 리소스를 캐싱해서 효율적으로 사용할 수 있는 경우를 의미한다.
  - **GET, HEAD**, POST, PATCH 메서드는 요청에 대해 중간 캐시에서 리소스를 가져올 수 있으므로 캐시 가능성이 있다고 할 수 있다.
  - 단, 일반적으로는 GET이나 HEAD 정도만 캐시로 이용이 가능하고, POST와 PATCH는 잘 지원하지 않는다. 스펙 상으로만 가능한 것 뿐이다.
  - 데이터의 변경을 야기하는 메서드의 경우는 캐시와 서버 간의 불일치가 발생할 수 있으므로 잘 지원하지 않는 것이라 보면된다.

<br>

추가적으로 안전성과 멱등성을 헷갈릴 수 있지만, 

안전성은 **한 번의 요청에 대해 서버에 변화를 주는가?** 를 따지는 문제이고, 

멱등성은 **여러 번의 요청에 대해 서버에 계속 다른 변화를 주는가?** 를 따지는 문제이다.

<br>

### HTTP 상태 코드(Status Code)

> HTTP 상태 코드는 클라이언트에게 HTTP 트랜잭션의 결과를 이해할 수 있는 설명을 제공하는데 사용한다.

**100~199 : 정보성 상태 코드**

- `100 Continue`
  - 클라이언트가 서버로 보낸 요청에 문제가 없으니 다음 요청을 이어서 보내도 된다는 것을 의미한다.
  - 클라이언트가 서버로 하여금 이를 검토하게 하려면 첫 번째 요청에서 `Expect: 100-continue`를 헤더로 보내야 한다.
  - 이후, 클라이언트는 본문을 보내기 전에 서버가 `100 Continue` 상태 코드로 응답하길 기다려야 한다.
- `101 Switching Protocols`
  - 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.

<br>

**200~299 : 성공 상태 코드**

- `200 Ok`
  - 요청은 정상이고, 본문은 요청된 리소스를 포함하고 있다는 것을 의미한다.
- `201 Created`
  - 새 리소스를 생성하라는 요청에 대해, 정상적으로 생성되었음을 의미한다.
  - 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 본문에 포함해야 한다.
- `202 Accepted`
  - 요청은 받아들였으나, 서버는 아직 그에 대한 어떤 동작도 수행하지 않았음을 의미한다.
- `204 No Content`
  - 요청이 성공하였으나, 클라이언트가 현재 페이지에서 벗어나지 않아도 되는 것을 의미한다.
  - 시작줄과 헤더에 대한 응답은 받지만, 본문 데이터는 포함하지 않는다.

<br>

**300~399 : 리다이렉션 상태 코드**

- `301 Moved Permanently`
  - 요청한 리소스가 Location 헤더에 주어진 URL로 완전히 옮겨졌다는 것을 의미한다.
  - 웹 브라우저는 해당 페이지로 리다이렉트하고, 검색 엔진은 해당 리소스로 연결되는 링크를 갱신한다.
- `302 Found`
  - 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다.
  - 웹 브라우저는 해당 페이지로 리다이렉트하나, 검색 엔진은 리소스에 대한 링크를 갱신하지 않는다.

- `303 See Other`
  - 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 알려주는 것을 의미한다.
  - 새 URL은 응답 메시지의 Location 헤더에 존재한다.
  - 주로 POST, PUT 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주고자 할 때 사용한다.
- `304 Not Modified`
  - 리소스의 복사본이 수정되지 않아 최신 상태이므로, 캐시를 이용하라고 알려주는 의미이다.
  - 클라이언트는 304 응답을 받으면 캐시에 저장된 리소스를 그대로 사용한다.
  - 해당 응답 메시지에서는 본문 데이터를 가지면 안된다. (캐시를 재사용 해야하기 때문)
  - `If-Modifed-Since` 혹은 `If-None-Match` 헤더를 포함한 `GET, HEAD` 요청에만 동작한다.
- `307 Temporary Redirect`
  - 302 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다.
  - 기존 HTTP 메서드와 본문의 내용을 유지한다.
- `308 Permanent Redirect`
  - 301 상태 코드와 같다.
  - 기존 HTTP 메서드와 본문의 내용을 유지한다.

<br>

`301`과 `302`는 각각 영구 리다이렉션, 일시 리다이렉션 기능을 하는데, 리다이렉트 할 때 HTTP 메서드를 GET으로 변경하고 본문을 제거할 수 있다.

따라서 리다이렉트 되었을 때 기존 HTTP 메서드를 그대로 유지해야 함에도 불구하고, 몇몇 사이트들은 GET으로 변경되는 경우가 있다. (일종의 버그)

이러한 문제를 방지하고자, 영구/일시 리다이렉션을 할 때 기존 HTTP 메서드와 본문 내용을 반드시 유지하는 307, 308 상태 코드가 탄생하게 되었다.

추가적으로 일시 리다이렉션을 하면서 GET으로 바뀌어야 할 때는, 302 대신 303을 사용하는 것이 명시적이다.

303은 302와 달리 HTTP 메서드의 변경과 본문 제거를 무조건 보장하기 때문에, 애매한 302보다는 의미가 더 확실하다.

<br>

**결론적으로**

- **영구 리다이렉션**의 경우 `301, 308`을 쓰자. 기존 HTTP 메서드와 본문 내용이 유지되어야 하는 경우, 308을 쓰자.
- **일시 리다이렉션**의 경우 `302, 303, 307`을 쓰자. 기존 HTTP 메서드와 본문 내용이 유지되어야 하는 경우, 307을 쓰자. HTTP 메서드가 GET으로 변경되어야 하고 본문이 제거되어야 하는 경우 303으로 명시하자.

<br>

**400~499 : 클라이언트 에러 상태 코드**

- `400 Bad Request`
  - 클라이언트가 잘못된 요청을 보냈다는 의미이다.
- `401 Unauthorized`
  - 리소스를 얻기 전, 클라이언트에게 스스로를 인증하라고 요구하는 의미이다.
  - 서버는 `WWW-Authenticate` 헤더를 포함한 응답을 보내어, 클라이언트에게 인증 자격 증명을 입력하라고 요구한다.
- `403 Forbidden`
  - 요청이 권한 문제로 인해 서버로 부터 거부되었음을 의미한다.
  - 401은 인증 문제이고, 403은 권한 문제임을 유의한다.
- `404 Not Found`
  - 요청한 URL에 해당하는 리소스를 찾을 수 없음을 의미한다.
- `405 Method Not Allowed`
  - 요청한 URL에 대해, 지원하지 않는 HTTP 메서드로 요청하였음을 의미한다.
  - 서버는 `Allow` 헤더를 통해, 클라이언트에게 어떠한 HTTP 메서드가 사용 가능한지 응답한다.

<br>

**500~599 : 서버 에러 상태 코드**

- `500 Internal Server Error`
  - 서버가 요청을 처리할 수 없게 만드는 에러를 만났다는 것을 의미한다.
  - 애매한 서버 문제에 대해서는 대부분 500을 많이 반환하는 편이다.
- `502 Bad Gateway`
  - 프록시나 게이트웨이 처럼 행동하는 서버가 잘못된 응답을 수신했음을 의미한다.
  - 최종 서버보다는, 중간 프록시 서버가 업스트림으로 부터 잘못된 응답을 받았을 때 해당 상태 코드를 응답한다.
- `503 Service Unavailable`
  - 일시적으로 서버가 요청을 처리할 수 없음을 의미한다.
  - 만약 서버가 언제 그 리소스를 사용할 수 있게 될지 알고 있다면, 서버는 `Retry-After` 헤더를 응답에 포함시키면 된다.
  - 보통 서버 점검을 하거나, 갑작스러운 트래픽 증가로 인한 과부하의 경우 등등 일시적으로 이용 불가일 때 사용한다.

<br>

### HTTP 헤더

**일반 헤더**

> **HTTP 메시지에 대한 기본적인 정보를 제공한다. 요청과 응답 모두에서 사용할 수 있다.**

- `Connection`
  - 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 한다.
  - `Keep-Alive` : 메시지를 교환 후 TCP 연결을 유지하는 옵션이다.
  - `Close` : 메시지 교환 후 TCP 연결을 종료하는 옵션이다.
- `Date`
  - 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.
- `Transfer-Encoding`
  - 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 알려준다.
  - `chunked` : 컨텐츠를 덩어리로 나누어 차례로 보내는 옵션이다. 이때는 Content-Length 헤더를 넣으면 안된다. (**분할 전송**)

- `Upgrade`
  - 발송자가 업그레이드하기를 원하는 새 버전이나 프로토콜을 알려준다.

<br>

**요청 헤더**

> **클라이언트가 보내는 요청 메시지에서만 의미를 갖는다.**

- `Host (필수)`
  - 요청의 대상이 되는 서버의 호스트 명과 포트를 준다.
  - 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 사용한다.
- `referer`
  - 현재의 요청 URL이 들어있었던 문서의 URL을 제공한다.
  - 예를 들어, A에서 B로 이동하는 요청에 대해, `Referer: A`를 포함해서 요청하면 A로부터 왔다는 것을 의미한다.

- `Accept`
  - 클라이언트가 선호하는 미디어 타입을 정의한다.
- `Accept-Charset`
  - 클라이언트가 선호하는 문자 인코딩을 정의한다.
- `Accept-Encoding`
  - 클라이언트가 선호하는 압축 인코딩을 정의한다.
- `Accept-Language`
  - 클라이언트가 선호하는 자연어를 정의한다.
  - Accept-Language를 적용하지 않으면, 기본값인 영어로 응답을 한다. 적용을 하면, 내가 원하는 언어에 맞는 데이터를 응답한다.

- `Authorization`
  - 클라이언트가 서버에게 제공하는 인증 정보를 담고 있다.

<br>

**응답 헤더**

> **서버가 보내는 응답 메시지에서만 의미를 갖는다.**

- `Retry-After`
  - 현재 리소스가 사용 불가능한 상태일 때, 언제 사용 가능해지는지에 대한 날짜 혹은 시각을 정의한다.
  - 보통 503 상태 코드에 해당하는 응답에서 사용한다.
- `Server`
  - origin 서버 애플리케이션의 이름과 버전을 정의한다.
  - 요청과 응답 사이에 있는 수많은 프록시 서버를 제외한, 최종 도달 서버에 대한 정보를 의미한다.
- `WWW-Authenticate`
  - 서버에서 클라이언트로 보낸 인증 요구의 목록을 의미한다.
  - 401 상태 코드의 응답 메시지에 보통 포함된다.

<br>

**엔티티 헤더**

> **요청과 응답 모두에서 사용할 수 있다. 보통 컨텐츠 타입과 같은 HTTP 메시지의 본문에 대한 자세한 정보를 담고 있다.**

- `Allow`
  - 해당 엔티티에 대해 수행될 수 있는 요청 메서드들을 나열한다.
  - 405 상태 코드의 응답 메시지에 보통 포함된다.

- `Location`
  - 클라이언트에게 엔티티가 실제로 어디에 위치하는지 알려준다. 리소스에 대한 새로운 위치를 알려줄 때 사용한다.
- `Content-Type`
  - 본문이 어떤 종류의 엔티티인지 나타낸다.
  - text/html, application/json, image/png
- `Content-Length`
  - 본문의 길이나 크기를 바이트 단위로 나타낸다.
  - `Transfer-Encoding: chunked`를 사용하면 `Content-Length`를 같이 사용하면 안된다.
- `Content-Encoding`
  - 본문에 적용된 인코딩을 나타낸다.
- `Content-Range`
  - 전체 리소스에서 해당 엔티티가 해당하는 범위를 바이트 단위로 나타낸다.

<br>

### HTTP 1.1, 2.0, 3.0

**HTTP 1.1**

- HTTP 1.0의 비연결성(Connectionless)로 인한 단기 연결은 매 요청마다 TCP handshake를 수행하므로 성능에 저하를 일으켰다.
- 따라서 HTTP 1.1에서는 단기 연결이 아닌 **지속 연결(Persistent connection)**을 채택하여, 지정한 timeout 동안 연속적 요청 사이의 커넥션을 닫지 않는다. (TCP handshake를 최초 1회만 하고 그 이후로 닫힐 때까지 생략 가능)
- 이를 위해, HTTP 1.1부터는 `Connection: Keep-alive` 헤더를 기본으로 세팅한다.
- **문제점**
  - Keep-alive 상황에서 하나의 요청을 받고 하나의 응답을 하는 방식으로는, 앞선 요청이 오래걸리면 뒤의 요청들이 모두 밀릴 수 있다. 따라서 HTTP 1.1에서는 `파이프라이닝(Pipelining)` 기법을 이용해서 여러 요청을 한꺼번에 처리하여 대기시간을 줄인다. 하지만 파이프라이닝 기법은 요청을 받는 것만 한번에 받을 뿐, 응답은 결국 순서대로 해야하므로 `HOLB(Head of Line Blocking)` 문제가 발생한다. HOLB는 앞선 응답이 느려지면, 후순위에 있는 응답들도 덩달아 느려지는 문제를 말한다. 따라서 HTTP 2.0에서는 이를 멀티플렉싱으로 대체한다.
  - TCP handshake 상황에서 처음에 SYN을 보내고 이후 서버로부터 SYN+ACK를 받을 때의 왕복 시간을 RTT(Round Trip Time)이라고 한다. HTTP 1.1의 특성 상 기본적으로 지속 연결이라 할지라도, 이런 TCP 구조상의 RTT 시간은 네트워크의 지연을 초래하는 주범이 될 수 밖에 없다.
  - HTTP 1.1은 헤더가 무겁다. 가끔 본문보다 헤더 데이터가 더 많을 정도이다. 지속 연결 상황에서도 매번 중복된 헤더값을 요청마다 보내야 하기 때문에 비효율이 발생한다.

<br>

**HTTP 2.0**

- HTTP 1.1에서는 파이프라이닝을 통해 여러 요청을 한번에 받아서 성능 개선을 꾀했지만, 응답의 순서를 맞춰야 하는 문제로 HOLB 문제를 피할 수 없었다.
- 따라서 HTTP 2.0에서는 요청 및 응답을 병렬적으로 처리하여 HOLB 문제를 개선하였다. 그리고 이를 `멀티플렉싱(Multiplexing)`이라고 한다.
- 멀티플렉싱은 **하나의 TCP 커넥션 내에서 여러 메시지 스트림**을 통해 여러 요청 및 응답을 순서 상관없이 주고 받는 것을 말한다. (병렬 처리)
  - `Frame` : HTTP 2.0에서 통신의 최소 단위가 된다. Header Frame과 Data Frame으로 나뉜다.
    - HTTP 2.0부터는 HTTP 메시지(헤더, 본문)가 text가 아닌 binary로 인코딩 되어 전송된다. 속도가 증가하고 오류률이 줄어들었다.
  - `Message` : 요청 혹은 응답의 단위로 다수의 Frame이 하나의 Message를 이룬다.
  - `Stream` : 연결된 커넥션 내에서 양방향으로 Message를 주고받는 하나의 흐름이다.

- HTTP 2.0은 또한 HTTP 1.1과 달리, 헤더를 압축할 수 있다. 따라서 여러 요청에서 중복되는 헤더 필드를 재전송하지 않는다.
- 문제점
  - HTTP 1.1, 2.0 모두 TCP를 사용함으로써 생기는 구조상의 문제가 여전히 존재한다. 바로 TCP handshake 과정에서의 RTT이다.
  - 또한, 멀티플렉싱을 통해 HOLB를 해결했으나 이는 어디까지나 여러 요청과 응답에 대한 HOLB만을 해결한 것이다. 하나의 요청/응답에 대한 패킷들의 순서가 바뀌거나 패킷이 손실되었을 때의 HOLB 문제는 여전히 해결하지 못한다.

<br>

**HTTP 3.0**

- HTTP 2.0은 1.1에 비해 혁신적인 성능 향상이 일어났으나, 여전히 RTT로 인한 지연 시간과 패킷 전송에 대한 HOLB 문제가 발생하였다.
- 이 두 문제점은 공통적인 것이 있는데, 바로 둘 다 TCP를 통신 방식으로 사용하기 때문이라는 것이다.
- 따라서 HTTP 3.0은 UDP를 채택하였다. 정확히 말하면 UDP를 기반으로 하는 QUIC 프로토콜을 채택하였다.
- `QUIC (Quick UDP Internet Connections)`
  - 별도의 handshake 과정없이 패킷을 목적지로 보내기만 하므로 RTT로 인한 지연이 발생하지 않는다.
  - TCP는 패킷 손실, 순서 변경 시 재전송을 요청하지만, UDP는 이러한 신뢰성과 순서를 보장하지 않기 때문에 HOLB가 발생하지 않는다.
  - 다만 UDP 자체의 신뢰성 문제가 대두되는데, UDP는 커스터마이징이 가능하므로 충분히 TCP 수준의 신뢰성을 탑재할 수 있다.

- QUIC에서는 RTT를 줄이기 위해 TCP handshake와 TLS handshake를 하나로 합쳤다. 기본적으로 HTTPS라고 가정하고 TLS 인증에 대한 연결을 최초 연결에 포함시키는 것이다. 또한 한번 연결이 성공하면 캐싱을 해두어, 추가 요청을 할 때 TCP 처럼 일일히 다시 handshake를 하지 않는다.
- HTTP 2.0에서 하나의 연결에서 여러 스트림으로 병렬 처리를 하였는데, HTTP 3.0에서는 스트림을 독립적으로 두어 하나의 스트림에서 패킷 전송에 문제가 발생하더라도 연결 자체가 정지되지 않는다. 해당 스트림만 정지된다. 따라서 패킷의 HOLB 문제가 발생하지 않는다. 조금 더 자세히 설명하면, HTTP 2.0에서는 하나의 스트림에서 여러 요청의 패킷들이 뒤섞일 수 있었다. 그래서 특정 요청의 패킷 손실이 일어나면 해당 스트림 자체가 정지하므로 HOLB가 발생한 것인데, HTTP 3.0에서는 각 요청에 대해 별도의 독립적인 스트림을 두어 패킷 손실이 일어나도 해당 요청의 스트림만 정지되므로 다른 요청에 대해 HOLB가 발생하지 않는다.

- QUIC은 기본적으로 TLS 암호화가 되어있다. 따라서 TCP와 달리 헤더 영역도 같이 암호화가 된다.
- QUIC은 클라이언트 IP를 기반으로 연결을 식별하지 않고, 별도의 Connection ID를 통해 클라이언트를 식별하기 때문에 무선 인터넷을 다른 걸로 변경했을 때 연결이 끊기지 않는다. 하지만 TCP는 클라이언트 IP를 가지고 식별하므로, 무선 인터넷이 변경되면 IP도 바뀌어서 TCP handshake를 다시 해야하므로 연결이 끊겼다 돌아온다.

<br>

---



## 2.2. HTTPS, SSL/TLS

HTTP는 아래와 같은 보안적인 약점이 존재한다.

- 암호화 하지 않은 통신이므로 도청이 가능하다.
- 통신 상대를 확인하지 않으므로 위장이 가능하다.
- 완전성을 증명할 수 없으므로 변조가 가능하다.

<br>

따라서 SSL/TLS라는 별도의 보안 계층을 HTTP와 합쳐서 위와 같은 약점을 보완한다. 그리고 이것을 HTTPS라고 한다.

> HTTPS (Hypertext Transfer Protocol Secure)
> SSL (Secure Socket Layer)
> TLS (Transport Layer Security)

![image](https://github.com/backend-team-study/cs-study/assets/49775540/92b72a2b-5e2c-4790-99bf-b6599a348334)

- SSL/TLS를 사용하면 클라이언트와 서버가 안전한 통신로를 확립하고 나서 해당 통신로를 사용해서 HTTP 통신을 할 수 있다.
- SSL/TLS 인증서를 통해 클라이언트와 서버가 위조되지 않은 개체임을 보장한다.

<br>

**대칭키 암호법**

- 인코딩을 할 때 사용하는 키와 디코딩 할 때 사용하는 키가 같은 암호법이다.
- 발신자와 수신자가 대화하려면 공유키를 가져하는 것이 단점이다. 즉 하나의 발신자가 여러 수신자와 대화하려면 수신자 수만큼 개인키를 가져야한다.

**비대칭 공개키 암호법**

- 인코딩을 할 때 사용하는 키와 디코딩 할 때 사용하는 키가 다른 암호법이다.
- 인코딩 키는 모두에게 공개되어 있고, 디코딩 키는 호스트가 개인키로 가지고 있다. 따라서 하나의 발신자는 수신자 수만큼의 개인키를 가지지 않아도 된다.

공개키 암호법은 느린 경향이 있다. 따라서 대칭키 암호법과 섞어서 혼성으로 많이 사용한다. 발신자와 수신자 사이의 의사소통 채널을 수립할 때는 공개키 방식으로 하고, 이후 데이터를 교환할 때는 이미 안전한 채널이 보장되어 있으므로 빠른 대칭키를 통해 편하게 암호화 한다.

<br>

그렇다면 의사소통 채널을 수립할 때, 서버로 부터 받은 공개키가 정말 신뢰할만한 키인지 어떻게 알까? 중간에 누가 바꿔치기 할 수도 있지 않을까?

이 문제를 해결하기 위해 **인증 기관(Certificate Authority, CA)**이 발행하는 공개키 증명서가 이용되고 있다. 이는 클라이언트와 서버를 제외한 제 3자이다.

1. 서버의 운영자는 인증 기관에 공개키를 제출한다.
2. 인증 기관은 서버의 공개키에 인증 기관의 비밀키로 디지털 서명을 하고, 서명이 끝난 공개키를 만든다. 
3. 이후 공개키 인증서에 서명이 끝난 공개키를 담는다. (디지털 증명서)
4. 서버는 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에게 보내고, 클라이언트는 인증 기관의 공개키로 증명서를 열어, 서버의 공개키가 진짜인지 확인한다.
5. 서버의 공개키로 암호화를 진행 후, 서버와 통신한다.

<br>

HTTPS 통신 과정은 다음과 같다.

![image](https://github.com/backend-team-study/cs-study/assets/49775540/13c10c9c-046f-449b-b098-84c6cb183469)

1. 일단 SSL 통신 과정에 앞서 TCP 3-way-handshake를 진행한다.
2. 이후 **SSL handshake**를 통해 인증된 서버인지 확인한다.
   - `ClientHello`
     - 클라이언트가 서버에 연결을 시도하며 전송하는 패킷이다.
     - 사용 가능한 Cipher Suite 목록, Session ID, SSL Protocol Version, Random Byte 등을 전달한다.
     - Cipher Suite 목록이란, 데이터 암호화 알고리즘 목록이라고 보면 된다. 이 중 하나를 선택하여 데이터를 암호화 하는 것이다.
   - `ServerHello`
     - 클라이언트가 보낸 ClientHello 패킷을 받아, 사용 가능한 Cipher Suite 중 하나를 선택하여 클라이언트에게 알린다. 이때 자신의 SSL Protocol Version 등의 정보도 같이 보낸다.
   - `Certificate`
     - 서버가 자신의 SSL 인증서를 Client에게 전달한다.
     - 이후, 클라이언트는 해당 SSL 인증서를 웹브라우저에 내장된 인증 기관의 공개키를 통해 복호화하여 인증서가 신뢰할만한지 검증할 것이다.
   - `ServerHelloDone`
     - 서버가 행동을 마쳤음을 전달한다.
   - `ClientKeyExchange`
     - 클라이언트는 앞으로 데이터를 암호화할 대칭키를 만들고, 이 대칭키를 서버의 공개키로 암호화하여 전달한다.
     - 여기서 전달되는 대칭키가, SSL handshake의 목적이다. 실제 전달될 데이터를 암호화할 둘만의 비밀키이기 때문이다.
   - `ClientCipherSpec / Finished`
     - 클라이언트와 서버 모두가 서로에게 보내는 패킷으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 다 되었음을 알린다.
     - 이후 SSL handshake를 종료한다.

<br>

---



## 2.3. DNS

> Domain Name System

![image](https://github.com/backend-team-study/cs-study/assets/49775540/1aa3ce6a-ddf4-4452-8964-1fceeca4b5be)

- 호스트의 도메인 네임을 네트워크 IP 주소로 변환하거나 그 반대의 역할을 수행하는 시스템을 의미한다.

- 클라이언트가 도메인 주소를 브라우저에 검색하면, DNS 서버에서 도메인 주소와 일치하는 IP 주소를 반환한다. 이후 해당 IP 주소로 접속하면 홈페이지가 열리는 방식이다.

<br>

**DNS 동작 순서 (재귀적 쿼리)**

![image](https://github.com/backend-team-study/cs-study/assets/49775540/26aadf1c-0bd4-4611-85b1-9f0b3baee810)

1. 웹 브라우저에 도메인 주소를 입력하면 먼저 PC에 저장된 Local DNS에게 도메인 주소에 대한 IP 주소를 요청한다.
   - `Local DNS (기지국 DNS 서버)`란, 로컬 사용자에게 인터넷을 제공해주는 ISP (ex. SK, KT, LG ...)의 DNS 서버를 의미한다.
   - 만약 없다면 한번도 접속하지 않은 것이므로 다른 DNS 서버에서 찾아야 한다. 이후에는 Local DNS에 캐싱되어 빠르게 찾을 수 있다.
2. Local DNS는 해당 도메인 주소를 가지고 Root DNS 서버에게 IP 주소를 요청한다.
   - `Root DNS (루트 네임서버)`란, ICANN이 직접 관리하는 DNS 서버로 가장 상단의 DNS 서버라고 생각하면 된다.
3. 만약 Root DNS가 IP 주소를 찾을 수 없다면, Local DNS에게 다른 DNS 서버에게 요청하라고 알려준다.
4. Local DNS는 com 도메인을 관리하는 TLD DNS 서버에게 다시 IP 주소를 요청한다.
   - `TLD DNS (Top Level Domain, 최상위 도메인 서버)`란, 도메인 등록 기관이 관리하는 서버로 도메인 주소에서 가장 마지막 부분에 해당한다. (com이나 co.kr과 같은 것들을 관리하는 곳)

5. 만약 TLD DNS가 IP 주소를 찾을 수 없다면, Local DNS에게 다른 DNS 서버에게 요청하라고 알려준다.
6. Local DNS는 Authoritative DNS 서버에게 IP 주소를 요청한다.
   - `Authoritative DNS 서버`란, 실제 개인의 도메인과 IP 주소의 관계가 저장되는 서버를 말한다. 보통 가비아와 같은 호스팅 업체나 조직 내의 네임서버를 말한다.

7. IP 주소를 찾으면 Local DNS 서버에게 해당 IP 주소를 응답한다.
8. Local DNS 서버는 응답받은 IP 주소를 캐싱한다. 이후 PC에게 돌려준다.

<br>

---



## 2.4. CORS

> Cross-Origin Resource Sharing (교차 출처 리소스 공유 정책)

```
Access to fetch at ‘https://myhompage.com’ from origin ‘http://localhost:3000’ has been 
blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 
If an opaque response serves your needs, set the request’s mode to ‘no-cors’ 
to fetch the resource with CORS disabled.
```

- html에서 img, video, script, link 태그는 기본적으로 Cross-Origin 정책을 지원한다. 따라서 출처가 같지 않아도 오류가 발생하지 않는다.
- 하지만, XMLHttpRequest, Fetch와 같은 Ajax 통신의 경우 기본적으로 Same-Origin 정책을 지원한다. 따라서 출처가 같지 않으면 오류가 발생한다.

<br>

**출처(Origin)**란, URL에서 `프로토콜과 호스트, 그리고 포트번호`를 말한다. 따라서 이 세 가지가 동일하면 같은 출처라고 여긴다.

**동일 출처 정책(Same-Origin Policy, SOP)**이란, 동일 출처의 서버에 있는 리소스는 자유롭게 가져올 수 있으나 다른 출처 서버에 있는 리소스는 가져올 수 없는 정책을 의미한다.

- 출처가 다르면 XSS나 CSRF와 같은 방법을 이용해 정보를 가로챌 수 있기 때문에, 보안 상 동일 출처의 리소스만 허용하도록 하였다.

- 예를 들어 동일 출처 정책이 없다면, 특정 사이트에 심어놓은 악성 자바스크립트 코드를 통해, 해당 사이트와 출처가 다른 해킹 사이트에 요청을 마음대로 보낼 수도 있게된다.

- 여기서 중요한 점은 **차단은 웹브라우저가 한다**는 것이다. (서버가 하는 것이 아니다!) 서버는 정상적으로 응답하지만 브라우저에서 받아들이지 않게된다.

<br>

하지만, 웹사이트를 사용하면서 무조건 동일 출처에만 요청을 보낼 수는 없다. 이런 예외를 위해 **교차 출처 리소스 공유 정책(CORS)**이 등장하였다.

기본적으로 SOP를 따르나, 특정 상황에서는 융통성 있게 교차 출처의 리소스를 허용하는 CORS를 따르는 것이다. 아래와 같이 하면 된다.

1. 클라이언트에서 HTTP 요청의 헤더에 `Origin`을 담아 서버로 요청한다.
   - `Origin` 헤더는 요청이 시작되는 출처를 담는다. Referer와 비슷하나, 전체 경로가 아닌 출처 부분만 전달한다.
2. 서버는 응답 헤더에 `Access-Control-Allow-Origin`을 담아 클라이언트로 전달한다.
   - 서버 단에서 해당 서버의 리소스에 접근하는 것이 허용된 출처를 명시해 두었는데, 그 출처를 전달한다.

3. 클라이언트 단에서 Origin과 서버가 전달한 Access-Control-Allow-Origin을 비교한다.
   - 비교 후 차단할지 말지 결정한다. 만약 유효하지 않다면 CORS 에러를 내뿜으며 응답을 사용하지 않고 버린다.

<br>

**CORS의 세 가지 시나리오**

1. **예비 요청 (Preflight Request)**

   ![image](https://github.com/backend-team-study/cs-study/assets/49775540/1af022af-deed-4b17-8398-8afbb7599b11)

   - 클라이언트가 서버에게 요청을 보낼 때는 요청을 한번에 보내는 것이 아니라 예비 요청을 먼저 보낸 후, 본 요청을 보낸다.

   - 예비 요청을 통해 클라이언트가 보내는 요청이 안전한 요청인지 확인하는 것이다. 이때는 `OPTIONS` 메서드를 사용한다.

   - **요청**
     - `Origin` : 클라이언트 자신의 출처
     - `Access-Control-Request-Method` : 본 요청에서 사용할 HTTP 메서드
     - `Access-Control-Request-Headers` : 본 요청에서 사용할 헤더 정보

   - **응답**
     - `Access-Control-Allow-Origin` : 서버에서 허용한 Origin
     - `Access-Control-Allow-Methods` : 헤더에 허용되는 메서드들의 목록 (Allow는 405 에러의 응답에 사용)
     - `Access-Control-Allow-Headers` : 허용되는 헤더 정보 목록
     - `Access-Control-Max-Age` : 해당 예비 요청이 브라우저에 캐시 될 수 있는 시간 (초)

   - 요청과 응답을 비교하여 해당 요청이 안전하다면 본 요청을 보내게 된다.

   - 예비 요청도 결국은 비용이므로 비효율을 야기한다. 따라서 Access-Control-Max-Age 응답 헤더를 통해 시간을 설정해주면, 해당 시간만큼 브라우저에 캐시되어 예비 요청을 다음부터 생략할 수 있다. (크롬은 2시간 까지 가능)

   

2. **단순 요청 (Simple Request)**

   - 예비 요청을 생략하고 바로 서버에 본 요청을 보낸 후, 서버의 응답 헤더의 Access-Control-Allow-Origin와 클라이언트의 Origin을 검사하는 방식이다.
   - **조건**
     1. 요청이 GET, HEAD, POST 메서드 중 하나여야 한다.
     2. `Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width` 헤더여야 한다.
     3. Content-Type 헤더가 `application/x-www-form-urlencoded, multipart/form-data, text/plain` 중 하나여야 한다.

   - 조건이 까다롭기 때문에 단순 요청 상황은 드물게 일어난다. (application/json 컨텐츠 타입을 많이 사용하기 때문)



3. **인증된 요청 (Credentialed Request)**

   - 클라이언트에서 서버에게 자격 인증 정보 (Credential)을 실어서 요청할 때 사용되는 방식이다.
   
   - **자격 인증 정보 (Credential)**란, `세션 ID가 저장된 쿠키`나 `Authorization 헤더에 설정하는 인증 토큰 값` 들을 말한다.
   
   - 클라이언트에서 서버로 요청할 때, 쿠키나 Authorization 헤더와 같은 인증 정보를 담아서 요청을 하면 인증된 요청이 발동된다는 것이다.
   
   - 인증된 요청 역시 예비 요청이 먼저 일어나고 본 요청이 일어난다.
   
   - **Credentials** (설정하지 않으면 쿠키 등의 인증 정보는 서버에게 자동으로 전송되지 않음) -> 자바스크립트 코드 단에서 설정
     
     - `same-origin` : 동일 출처 간 요청에만 인증 정보를 담을 수 있다.
     - `include` : 모든 요청에 인증 정보를 담을 수 있다.
     - `omit` : 모든 요청에 인증 정보를 담지 않는다.
     
   - 서버 또한 이러한 인증된 요청에서는 일반적인 CORS와 다르게 응답한다. (인증된 요청이므로 와일드카드가 아닌 명시적으로 응답)

     - 응답 헤더의 `Access-Control-Allow-Credentials` 항목을 true로 설정해야 한다.
     - 응답 헤더의 `Access-Control-Allow-Origin` 의 값에 와일드카드 문자("*")는 사용할 수 없다.
     - 응답 헤더의 `Access-Control-Allow-Methods` 의 값에 와일드카드 문자("*")는 사용할 수 없다.
     - 응답 헤더의 `Access-Control-Allow-Headers` 의 값에 와일드카드 문자("*")는 사용할 수 없다
   

<br>

---



## 2.5. 인증

> 서버가 클라이언트 인증을 확인하는 대표적인 방법 세 가지

### Cookie

- key-value 형식의 문자열 덩어리이다.
- 특정 웹사이트를 방문하는 경우, 해당 사이트가 사용하고있는 서버를 통해 클라이언트 브라우저에 설치되는 기록 정보 파일을 의미한다.
- 사용자마다 브라우저에 특정 정보를 저장하기 때문에 고유 정보에 대한 식별이 된다.
- **과정**
  1. 클라이언트가 서버에 요청을 보낸다.
  2. 서버는 클라이언트에게 보내는 응답에, 쿠키에 저장할 정보를 `Set-Cookie` 헤더에 담아 보낸다.
  3. 클라이언트는 이후 요청을 보낼 때 마다 해당 쿠키의 데이터를 `Cookie` 헤더에 담아 요청한다. 이 데이터를 바탕으로 서버에서 사용자를 식별 및 인증한다.

- **단점**
  - 요청 시 쿠키의 값을 그대로 보내므로 보안에 취약하다.
  - 쿠키에는 용량 제한이 있으므로 많이 담을 수 없다.
  - 웹 브라우저 종류마다 쿠키 지원 방식이 다르므로, 브라우저 간 쿠키 공유는 불가능하다.
  - 쿠키가 커질수록 네트워크 부하가 심하다.

<br>

### Session

- 쿠키의 보안이슈로 인해, 클라이언트 측에서 인증 정보를 가지고 있는 것이 아닌, 서버에서 세션의 형태로 인증 정보를 갖게 되었다.
- 서버의 메모리나 데이터베이스에 사용자 세션 정보를 저장하는 방식이다.
- 보통 세션 객체는 Session ID와 이에 대응하는 Value로 구성된다.
- **과정**
  1. 사용자가 로그인을 하면 서버에 세션이 저장된다. 이때 Session ID를 기준으로 해당 사용자의 인증 정보를 저장한다.
  2. 서버에서는 쿠키에 Session ID를 담아 클라이언트로 응답한다.
  3. 클라이언트는 이후 모든 요청에 대해 쿠키를 담아 요청한다. 쿠키에는 Session ID가 있으므로 서버에서 이를 확인하여 인증한다.

- **단점**
  - Session ID 자체는 의미가 없는 값이긴 하지만, 해커가 ID를 탈취하여 클라이언트인척 할 수 있다.
  - 서버의 세션 저장소에 정보가 많아지면 서버 부하가 심해진다.

<br>

### JWT(Json Web Token)

![image](https://github.com/backend-team-study/cs-study/assets/49775540/36c7d1d9-5ffb-4051-ad1c-c2a7765ca244)

- 세션은 별도의 세션 저장소가 필요하므로 서버에 많은 부하가 있었다.
- 토큰 방식은 클라이언트에서 모든 정보를 가지고 있기 때문에 서버에 별도의 저장소가 필요없다. 단순히 서버는 위변조만 파악하면 된다.
- 웹에는 쿠키와 세션이 있지만, 앱에서는 없기 때문에 앱에서는 토큰 방식이 많이 사용된다.
- JWT는 헤더, 페이로드, 시그니처로 나뉜다.

<br>

---



## 2.6. 웹 보안

### XSS

> Cross Site Scripting

- 권한이 없는 사용자가 악의적인 용도로 웹사이트에 자바스크립트 코드를 삽입하는 공격 기법을 말한다.

- XSS 공격을 통해 쿠키나 세션 ID와 같은 인증 정보가 탈취될 수 있으며, 해커가 관리자 권한을 획득하거나, 악성 프로그램이 있는 사이트로 리다이렉트 시키거나 등등 여러 위험성이 존재한다.

- **종류**

  1. **Reflected XSS**

     - 악성 자바스크립트 코드를 클라이언트에게 직접 전달하여 공격하는 방식을 말한다.

     - 보통 URL에 특정 악성 스크립트 코드를 포함시켜 해당 URL을 사용자에게 노출시킨다. 이후 사용자가 URL을 클릭하면 스크립트가 실행된다.

  2. **Stored XSS**
     - 악성 자바스크립트 코드를 서버에 저장시킨 다음, 클라이언트의 요청/응답 과정을 통해 공격하는 방식을 말한다.

  3. **DOM Based XSS**

     - 브라우저가 DOM Tree를 생성할 때, 악성 자바스크립트 코드가 DOM Tree의 일부로 구성되어 공격하는 방식을 말한다.

     - 서버의 응답에 악성 스크립트가 추가되는 것이 아니라, 응답이 브라우저에 띄워지면서 스크립트가 실행되는 특징이 있다.

<br>

### SQL Injection

- 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격 기법을 말한다. (가장 흔한 공격)
- SQL Injection 공격을 통해 사용자의 개인 정보나 기밀 정보가 누설될 수 있는 위험성이 존재한다.
- 특정 정보를 알아낼 수 있는 SQL 문의 전체 혹은 일부를 주입하여 서버의 데이터베이스 내의 정보를 가져오거나, 삭제하거나, 수정하는 등 조작할 수 있다.

<br>

### CSRF

> Cross Site Request Forgery

- 인증된 사용자가 의도하지 않는 개인 정보나 설정 정보 등을 공격자가 설치해 둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격 기법이다.
- 해커가 사용자의 권한을 빌려서 악의적인 행동을 하는 것들을 말한다.
- 위조 요청을 전송하는 서비스에 사용자가 로그인 상태여야 하고, 사용자가 해커가 만든 피싱 사이트에 접속하여 서비스에 무언가 요청을 보내도록 하는 함정에 걸리는 방식으로 공격한다.

- Referer를 검증하거나 Security token(= CSRF token)을 사용하여 대응할 수 있다.
  - `Referer 검증` : 요청 헤더의 referer 값을 확인하여 요청 URL이 현재 URL과 일치하는지 확인한다. 하지만 XSS 취약점이 있는 서비스의 경우 referer로 막지 못하는 경우가 있다.
  - `CSRF token` : 사용자의 세션에 임의의 난수 값을 저장하고, 요청마다 해당 난수 값(= CSRF token)을 포함하여 전송한다. 이후 서버에서 세션에 저장된 토큰과 요청 메시지에 있는 난수 값이 일치하는지 보고, 일치하면 정상이라고 판단한다.
- GET 보다는 POST, PUT, PATCH, DELETE와 같은 쓰기 요청에 대해서만 방어하면 된다.

<br>

---



## 2.7. 질문 모음

1. HTTP의 무상태성에 대해 설명해주세요. 그리고 상태를 저장할 필요가 있을 때는 어떤 기술을 이용할 수 있나요?
2. HTTP 메서드 중 GET과 POST의 차이를 설명해주세요.
3. HTTP 메서드 중 PUT과 PATCH의 차이를 설명해주세요.
4. HTTP 메서드의 안전성과 멱등성에 대해 설명해주세요. 둘은 어떤 차이가 있을까요?
5. PUT과 PATCH 메서드는 각각 멱등한가요? 아니라면 그 이유를 설명해주세요.

6. HTTP 상태 코드 중에서 301과 302는 어떤 차이가 있을까요?
7. 쇼핑몰 사이트에서 상품을 주문하는 POST 요청에 대해 발생할 수 있는 문제점은 어떤게 있고, 이를 어떻게 해결할 수 있는지 리다이렉션과 연관지어서 얘기해주세요.
8. HTTP 상태 코드 중에서 401과 403은 어떤 차이가 있을까요?
9. HTTP Connection 헤더의 Keep-Alive 옵션은 어떤 걸 의미하나요? HTTP 버전 별로 해당 옵션에 대한 차이점이 있다면 설명해주시고, 왜 그런 차이점이 발생했는지도 설명해주세요.
10. HTTP 2.0는 1.1에 비해 어떤 점이 개선되었나요? 왜 개선되었나요?
11. HTTP 3.0은 2.0에 비해 어떤 점이 개선되었나요? 왜 개선되었나요?
12. 와이파이를 통해 웹사이트에 접속한 도중, 다른 와이파이로 바꿀 때 HTTP 2.0과 3.0에 따른 차이가 있을까요? 있다면 어떤 원리 때문일까요?
13. 대칭키 암호화와 공개키 암호화에 대해 간단하게 설명해주세요.
14. HTTPS는 일반 HTTP에 비해 어떤 과정이 추가적으로 진행되나요? 과정까지 알고 계시다면 최대한 아는대로 설명해주세요.
15. SSL/TLS 인증서를 발급하는 인증 기관이 필요한 이유와 역할에 대해 간단히 설명해주세요.
16. DNS가 필요한 이유는 무엇일까요? 동작 원리 말고 이유만 설명해주세요.
17. 웹브라우저에 특정 도메인 주소를 입력했을 때, DNS를 통해 IP 주소를 찾아가는 동작 방식에 대해 설명해주세요.
18. CORS란 무엇인가요?
19. CORS의 시나리오 중 예비 요청은 무엇인가요? 왜 필요할까요? 예비 요청의 단점은 무엇이고 이를 어떤식으로 해결하나요?
20. 쿠키와 세션은 각각 무엇인가요? 어떤 단점들이 존재할까요?
21. JWT란 무엇인가요? 세션 인증 방식과 JWT 인증 방식의 차이는 무엇일까요?
22. XSS란 무엇인가요?
23. SQL Injection이란 무엇인가요?
24. CSRF란 무엇인가요? 대응 방법 아무거나 하나만 설명해주세요.